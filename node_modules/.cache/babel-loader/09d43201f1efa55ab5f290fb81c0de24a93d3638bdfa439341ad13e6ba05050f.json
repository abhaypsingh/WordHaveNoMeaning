{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { v4 as uuidv4 } from 'uuid';\nimport { selectWordsForGame } from '../../services/wordService';\n\n// Initial state\nconst initialState = {\n  gameSession: null,\n  loading: false,\n  error: null\n};\n\n// Async thunks\nexport const initializeGame = createAsyncThunk('game/initializeGame', async (settings, {\n  rejectWithValue\n}) => {\n  try {\n    // Get words for the game based on difficulty and round count\n    const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\n\n    // Create game session\n    const gameSession = {\n      id: uuidv4(),\n      startTime: new Date(),\n      endTime: null,\n      settings,\n      currentRound: 0,\n      totalRounds: settings.roundCount,\n      score: 0,\n      rounds: [],\n      completed: false,\n      encounteredConcepts: []\n    };\n\n    // Create rounds for each selected word\n    const rounds = selectedWords.map((word, index) => {\n      // Generate options for this word\n      const options = generateMeaningOptions(word);\n\n      // Select a contradiction meaning\n      const correctMeaning = selectContradictionMeaning(word, options);\n\n      // Mark the contradiction meaning in the options\n      const markedOptions = options.map(option => ({\n        ...option,\n        isContradiction: option.text === correctMeaning.definition\n      }));\n      return {\n        roundNumber: index + 1,\n        word,\n        correctMeaning,\n        options: markedOptions,\n        selectedOption: null,\n        timeSpent: 0,\n        score: 0,\n        completed: false\n      };\n    });\n\n    // Add rounds to game session\n    gameSession.rounds = rounds;\n    return gameSession;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const startNextRound = createAsyncThunk('game/startNextRound', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    console.log(\"startNextRound thunk called\");\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    console.log(\"Current gameSession state:\", gameSession);\n    if (!gameSession) {\n      console.error(\"No active game session\");\n      throw new Error('No active game session');\n    }\n    if (gameSession.currentRound >= gameSession.totalRounds) {\n      console.error(\"No more rounds available\");\n      throw new Error('No more rounds available');\n    }\n    const nextRound = gameSession.currentRound + 1;\n    console.log(\"Starting next round:\", nextRound);\n    return nextRound;\n  } catch (error) {\n    console.error(\"Error in startNextRound:\", error);\n    return rejectWithValue(error.message);\n  }\n});\nexport const processUserSelection = createAsyncThunk('game/processUserSelection', async ({\n  optionIndex,\n  timeSpent\n}, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    console.log(\"processUserSelection thunk called with:\", {\n      optionIndex,\n      timeSpent\n    });\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    console.log(\"Current gameSession state:\", gameSession);\n    if (!gameSession) {\n      console.error(\"No active game session\");\n      throw new Error('No active game session');\n    }\n    const currentRound = gameSession.rounds[gameSession.currentRound - 1];\n    if (!currentRound) {\n      console.error(\"Invalid round\");\n      throw new Error('Invalid round');\n    }\n    console.log(\"Current round:\", currentRound);\n    const selectedOption = currentRound.options[optionIndex];\n    if (!selectedOption) {\n      console.error(\"Invalid option selected\");\n      throw new Error('Invalid option selected');\n    }\n    console.log(\"Selected option:\", selectedOption);\n\n    // Calculate score\n    const baseScore = selectedOption.isCorrect ? 100 : 25;\n    const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\n    const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\n    const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\n    console.log(\"Calculated score:\", score);\n    return {\n      roundIndex: gameSession.currentRound - 1,\n      optionIndex,\n      timeSpent,\n      score\n    };\n  } catch (error) {\n    console.error(\"Error in processUserSelection:\", error);\n    return rejectWithValue(error.message);\n  }\n});\nexport const completeGame = createAsyncThunk('game/completeGame', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n\n    // Calculate final statistics\n    let totalTimeSpent = 0;\n    let correctAnswers = 0;\n    gameSession.rounds.forEach(round => {\n      totalTimeSpent += round.timeSpent;\n      if (round.selectedOption !== null) {\n        const selectedOption = round.options[round.selectedOption];\n        if (selectedOption && selectedOption.isCorrect) {\n          correctAnswers += 1;\n        }\n      }\n    });\n    const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\n    const accuracyRate = correctAnswers / gameSession.totalRounds * 100;\n    return {\n      endTime: new Date(),\n      totalTimeSpent,\n      correctAnswers,\n      averageTimePerRound,\n      accuracyRate\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\n\n// Helper functions\nfunction generateMeaningOptions(word) {\n  // In a real implementation, this would generate options based on the word's meanings\n  // and distractors from the database. For now, we'll create a simplified version.\n\n  // Include actual meanings (up to 3)\n  const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\n  const options = actualMeanings.map((meaning, index) => ({\n    index,\n    text: meaning.definition,\n    isCorrect: true,\n    isContradiction: false\n  }));\n\n  // Fill remaining slots with distractors\n  const neededDistractors = 4 - options.length;\n  if (neededDistractors > 0) {\n    // In a real implementation, these would come from a distractor database\n    const dummyDistractors = [\"To prepare food by heating it in an oven\", \"A small, round fruit with red or green skin\", \"A device used for measuring time\", \"A large, four-legged animal with a trunk\"].slice(0, neededDistractors);\n    dummyDistractors.forEach((distractor, _index) => {\n      options.push({\n        index: options.length,\n        text: distractor,\n        isCorrect: false,\n        isContradiction: false\n      });\n    });\n  }\n\n  // Shuffle options\n  return shuffleArray(options);\n}\nfunction selectContradictionMeaning(word, options) {\n  // In a real implementation, this would select a meaning that has contradiction sentences\n  // For now, we'll just pick one of the correct meanings\n\n  const correctOptions = options.filter(option => option.isCorrect);\n  if (correctOptions.length === 0) {\n    // Fallback to any meaning if no correct options\n    return word.meanings[0];\n  }\n  const randomIndex = Math.floor(Math.random() * correctOptions.length);\n  const selectedOption = correctOptions[randomIndex];\n\n  // Find the corresponding meaning\n  return word.meanings.find(meaning => meaning.definition === selectedOption.text) || word.meanings[0];\n}\nfunction calculateTimeBonus(timeSpent, timeLimit) {\n  if (timeLimit === 0) {\n    return 1.0; // No time bonus if no time limit\n  }\n\n  // Calculate bonus factor (1.0 to 1.5)\n  const timeRatio = 1 - timeSpent / timeLimit;\n  const bonus = 1.0 + timeRatio * 0.5;\n\n  // Ensure bonus is within bounds\n  return Math.max(1.0, Math.min(1.5, bonus));\n}\nfunction getDifficultyMultiplier(difficulty) {\n  switch (difficulty) {\n    case 'easy':\n      return 1.0;\n    case 'medium':\n      return 1.25;\n    case 'hard':\n      return 1.5;\n    default:\n      return 1.0;\n  }\n}\nfunction shuffleArray(array) {\n  const result = [...array];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\n\n// Create slice\nconst gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    resetGame: state => {\n      state.gameSession = null;\n      state.loading = false;\n      state.error = null;\n    },\n    restoreSession: (state, action) => {\n      state.gameSession = action.payload;\n      state.loading = false;\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Initialize game\n    .addCase(initializeGame.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(initializeGame.fulfilled, (state, action) => {\n      state.gameSession = action.payload;\n      state.loading = false;\n    }).addCase(initializeGame.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Start next round\n    .addCase(startNextRound.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(startNextRound.fulfilled, (state, action) => {\n      console.log(\"startNextRound.fulfilled reducer called with payload:\", action.payload);\n      if (state.gameSession) {\n        state.gameSession.currentRound = action.payload;\n        console.log(\"Updated gameSession.currentRound to:\", action.payload);\n      } else {\n        console.error(\"Cannot update currentRound: gameSession is null\");\n      }\n      state.loading = false;\n    }).addCase(startNextRound.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Process user selection\n    .addCase(processUserSelection.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(processUserSelection.fulfilled, (state, action) => {\n      console.log(\"processUserSelection.fulfilled reducer called with payload:\", action.payload);\n      if (state.gameSession) {\n        const {\n          roundIndex,\n          optionIndex,\n          timeSpent,\n          score\n        } = action.payload;\n        const round = state.gameSession.rounds[roundIndex];\n        if (round) {\n          console.log(\"Updating round state:\", roundIndex);\n          round.selectedOption = optionIndex;\n          round.timeSpent = timeSpent;\n          round.score = score;\n          round.completed = true;\n\n          // Update total score\n          state.gameSession.score += score;\n          console.log(\"Updated round state:\", round);\n        } else {\n          console.error(\"Cannot update round: round is null\");\n        }\n      } else {\n        console.error(\"Cannot update round: gameSession is null\");\n      }\n      state.loading = false;\n    }).addCase(processUserSelection.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Complete game\n    .addCase(completeGame.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(completeGame.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        state.gameSession.endTime = action.payload.endTime;\n        state.gameSession.completed = true;\n      }\n      state.loading = false;\n    }).addCase(completeGame.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\n\n// Export actions and reducer\nexport const {\n  resetGame,\n  restoreSession\n} = gameSlice.actions;\nexport default gameSlice.reducer;\n\n// Selectors\nexport const selectGameSession = state => state.game.gameSession;\nexport const selectCurrentRound = state => {\n  const {\n    gameSession\n  } = state.game;\n  if (!gameSession || gameSession.currentRound === 0) {\n    return null;\n  }\n  return gameSession.rounds[gameSession.currentRound - 1];\n};\nexport const selectGameLoading = state => state.game.loading;\nexport const selectGameError = state => state.game.error;","map":{"version":3,"names":["createSlice","createAsyncThunk","v4","uuidv4","selectWordsForGame","initialState","gameSession","loading","error","initializeGame","settings","rejectWithValue","selectedWords","difficulty","roundCount","id","startTime","Date","endTime","currentRound","totalRounds","score","rounds","completed","encounteredConcepts","map","word","index","options","generateMeaningOptions","correctMeaning","selectContradictionMeaning","markedOptions","option","isContradiction","text","definition","roundNumber","selectedOption","timeSpent","message","startNextRound","_","getState","console","log","game","Error","nextRound","processUserSelection","optionIndex","baseScore","isCorrect","timeBonus","calculateTimeBonus","timeLimit","difficultyMultiplier","getDifficultyMultiplier","Math","round","roundIndex","completeGame","totalTimeSpent","correctAnswers","forEach","averageTimePerRound","accuracyRate","actualMeanings","meanings","slice","min","length","meaning","neededDistractors","dummyDistractors","distractor","_index","push","shuffleArray","correctOptions","filter","randomIndex","floor","random","find","timeRatio","bonus","max","array","result","i","j","gameSlice","name","reducers","resetGame","state","restoreSession","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectGameSession","selectCurrentRound","selectGameLoading","selectGameError"],"sources":["C:/Users/abhay/Downloads/WordsEmptyMeaning/src/store/slices/gameSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { selectWordsForGame } from '../../services/wordService';\r\n\r\n// Initial state\r\nconst initialState = {\r\n  gameSession: null,\r\n  loading: false,\r\n  error: null,\r\n};\r\n\r\n// Async thunks\r\nexport const initializeGame = createAsyncThunk(\r\n  'game/initializeGame',\r\n  async (settings, { rejectWithValue }) => {\r\n    try {\r\n      // Get words for the game based on difficulty and round count\r\n      const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\r\n      \r\n      // Create game session\r\n      const gameSession = {\r\n        id: uuidv4(),\r\n        startTime: new Date(),\r\n        endTime: null,\r\n        settings,\r\n        currentRound: 0,\r\n        totalRounds: settings.roundCount,\r\n        score: 0,\r\n        rounds: [],\r\n        completed: false,\r\n        encounteredConcepts: [],\r\n      };\r\n      \r\n      // Create rounds for each selected word\r\n      const rounds = selectedWords.map((word, index) => {\r\n        // Generate options for this word\r\n        const options = generateMeaningOptions(word);\r\n        \r\n        // Select a contradiction meaning\r\n        const correctMeaning = selectContradictionMeaning(word, options);\r\n        \r\n        // Mark the contradiction meaning in the options\r\n        const markedOptions = options.map(option => ({\r\n          ...option,\r\n          isContradiction: option.text === correctMeaning.definition\r\n        }));\r\n        \r\n        return {\r\n          roundNumber: index + 1,\r\n          word,\r\n          correctMeaning,\r\n          options: markedOptions,\r\n          selectedOption: null,\r\n          timeSpent: 0,\r\n          score: 0,\r\n          completed: false,\r\n        };\r\n      });\r\n      \r\n      // Add rounds to game session\r\n      gameSession.rounds = rounds;\r\n      \r\n      return gameSession;\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const startNextRound = createAsyncThunk(\r\n  'game/startNextRound',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n      console.log(\"startNextRound thunk called\");\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      console.log(\"Current gameSession state:\", gameSession);\r\n      \r\n      if (!gameSession) {\r\n        console.error(\"No active game session\");\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      if (gameSession.currentRound >= gameSession.totalRounds) {\r\n        console.error(\"No more rounds available\");\r\n        throw new Error('No more rounds available');\r\n      }\r\n      \r\n      const nextRound = gameSession.currentRound + 1;\r\n      console.log(\"Starting next round:\", nextRound);\r\n      return nextRound;\r\n    } catch (error) {\r\n      console.error(\"Error in startNextRound:\", error);\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const processUserSelection = createAsyncThunk(\r\n  'game/processUserSelection',\r\n  async ({ optionIndex, timeSpent }, { getState, rejectWithValue }) => {\r\n    try {\r\n      console.log(\"processUserSelection thunk called with:\", { optionIndex, timeSpent });\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      console.log(\"Current gameSession state:\", gameSession);\r\n      \r\n      if (!gameSession) {\r\n        console.error(\"No active game session\");\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      const currentRound = gameSession.rounds[gameSession.currentRound - 1];\r\n      \r\n      if (!currentRound) {\r\n        console.error(\"Invalid round\");\r\n        throw new Error('Invalid round');\r\n      }\r\n      \r\n      console.log(\"Current round:\", currentRound);\r\n      \r\n      const selectedOption = currentRound.options[optionIndex];\r\n      \r\n      if (!selectedOption) {\r\n        console.error(\"Invalid option selected\");\r\n        throw new Error('Invalid option selected');\r\n      }\r\n      \r\n      console.log(\"Selected option:\", selectedOption);\r\n      \r\n      // Calculate score\r\n      const baseScore = selectedOption.isCorrect ? 100 : 25;\r\n      const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\r\n      const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\r\n      \r\n      const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\r\n      console.log(\"Calculated score:\", score);\r\n      \r\n      return {\r\n        roundIndex: gameSession.currentRound - 1,\r\n        optionIndex,\r\n        timeSpent,\r\n        score,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Error in processUserSelection:\", error);\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const completeGame = createAsyncThunk(\r\n  'game/completeGame',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      if (!gameSession) {\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      // Calculate final statistics\r\n      let totalTimeSpent = 0;\r\n      let correctAnswers = 0;\r\n      \r\n      gameSession.rounds.forEach(round => {\r\n        totalTimeSpent += round.timeSpent;\r\n        \r\n        if (round.selectedOption !== null) {\r\n          const selectedOption = round.options[round.selectedOption];\r\n          if (selectedOption && selectedOption.isCorrect) {\r\n            correctAnswers += 1;\r\n          }\r\n        }\r\n      });\r\n      \r\n      const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\r\n      const accuracyRate = (correctAnswers / gameSession.totalRounds) * 100;\r\n      \r\n      return {\r\n        endTime: new Date(),\r\n        totalTimeSpent,\r\n        correctAnswers,\r\n        averageTimePerRound,\r\n        accuracyRate,\r\n      };\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\n// Helper functions\r\nfunction generateMeaningOptions(word) {\r\n  // In a real implementation, this would generate options based on the word's meanings\r\n  // and distractors from the database. For now, we'll create a simplified version.\r\n  \r\n  // Include actual meanings (up to 3)\r\n  const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\r\n  \r\n  const options = actualMeanings.map((meaning, index) => ({\r\n    index,\r\n    text: meaning.definition,\r\n    isCorrect: true,\r\n    isContradiction: false,\r\n  }));\r\n  \r\n  // Fill remaining slots with distractors\r\n  const neededDistractors = 4 - options.length;\r\n  \r\n  if (neededDistractors > 0) {\r\n    // In a real implementation, these would come from a distractor database\r\n    const dummyDistractors = [\r\n      \"To prepare food by heating it in an oven\",\r\n      \"A small, round fruit with red or green skin\",\r\n      \"A device used for measuring time\",\r\n      \"A large, four-legged animal with a trunk\",\r\n    ].slice(0, neededDistractors);\r\n    \r\n    dummyDistractors.forEach((distractor, _index) => {\r\n      options.push({\r\n        index: options.length,\r\n        text: distractor,\r\n        isCorrect: false,\r\n        isContradiction: false,\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Shuffle options\r\n  return shuffleArray(options);\r\n}\r\n\r\nfunction selectContradictionMeaning(word, options) {\r\n  // In a real implementation, this would select a meaning that has contradiction sentences\r\n  // For now, we'll just pick one of the correct meanings\r\n  \r\n  const correctOptions = options.filter(option => option.isCorrect);\r\n  \r\n  if (correctOptions.length === 0) {\r\n    // Fallback to any meaning if no correct options\r\n    return word.meanings[0];\r\n  }\r\n  \r\n  const randomIndex = Math.floor(Math.random() * correctOptions.length);\r\n  const selectedOption = correctOptions[randomIndex];\r\n  \r\n  // Find the corresponding meaning\r\n  return word.meanings.find(meaning => meaning.definition === selectedOption.text) || word.meanings[0];\r\n}\r\n\r\nfunction calculateTimeBonus(timeSpent, timeLimit) {\r\n  if (timeLimit === 0) {\r\n    return 1.0; // No time bonus if no time limit\r\n  }\r\n  \r\n  // Calculate bonus factor (1.0 to 1.5)\r\n  const timeRatio = 1 - (timeSpent / timeLimit);\r\n  const bonus = 1.0 + (timeRatio * 0.5);\r\n  \r\n  // Ensure bonus is within bounds\r\n  return Math.max(1.0, Math.min(1.5, bonus));\r\n}\r\n\r\nfunction getDifficultyMultiplier(difficulty) {\r\n  switch (difficulty) {\r\n    case 'easy':\r\n      return 1.0;\r\n    case 'medium':\r\n      return 1.25;\r\n    case 'hard':\r\n      return 1.5;\r\n    default:\r\n      return 1.0;\r\n  }\r\n}\r\n\r\nfunction shuffleArray(array) {\r\n  const result = [...array];\r\n  \r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n// Create slice\r\nconst gameSlice = createSlice({\r\n  name: 'game',\r\n  initialState,\r\n  reducers: {\r\n    resetGame: (state) => {\r\n      state.gameSession = null;\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n    restoreSession: (state, action) => {\r\n      state.gameSession = action.payload;\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Initialize game\r\n      .addCase(initializeGame.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(initializeGame.fulfilled, (state, action) => {\r\n        state.gameSession = action.payload;\r\n        state.loading = false;\r\n      })\r\n      .addCase(initializeGame.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Start next round\r\n      .addCase(startNextRound.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(startNextRound.fulfilled, (state, action) => {\r\n        console.log(\"startNextRound.fulfilled reducer called with payload:\", action.payload);\r\n        if (state.gameSession) {\r\n          state.gameSession.currentRound = action.payload;\r\n          console.log(\"Updated gameSession.currentRound to:\", action.payload);\r\n        } else {\r\n          console.error(\"Cannot update currentRound: gameSession is null\");\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(startNextRound.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Process user selection\r\n      .addCase(processUserSelection.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(processUserSelection.fulfilled, (state, action) => {\r\n        console.log(\"processUserSelection.fulfilled reducer called with payload:\", action.payload);\r\n        if (state.gameSession) {\r\n          const { roundIndex, optionIndex, timeSpent, score } = action.payload;\r\n          const round = state.gameSession.rounds[roundIndex];\r\n          \r\n          if (round) {\r\n            console.log(\"Updating round state:\", roundIndex);\r\n            round.selectedOption = optionIndex;\r\n            round.timeSpent = timeSpent;\r\n            round.score = score;\r\n            round.completed = true;\r\n            \r\n            // Update total score\r\n            state.gameSession.score += score;\r\n            console.log(\"Updated round state:\", round);\r\n          } else {\r\n            console.error(\"Cannot update round: round is null\");\r\n          }\r\n        } else {\r\n          console.error(\"Cannot update round: gameSession is null\");\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(processUserSelection.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Complete game\r\n      .addCase(completeGame.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(completeGame.fulfilled, (state, action) => {\r\n        if (state.gameSession) {\r\n          state.gameSession.endTime = action.payload.endTime;\r\n          state.gameSession.completed = true;\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(completeGame.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      });\r\n  },\r\n});\r\n\r\n// Export actions and reducer\r\nexport const { resetGame, restoreSession } = gameSlice.actions;\r\nexport default gameSlice.reducer;\r\n\r\n// Selectors\r\nexport const selectGameSession = (state) => state.game.gameSession;\r\nexport const selectCurrentRound = (state) => {\r\n  const { gameSession } = state.game;\r\n  \r\n  if (!gameSession || gameSession.currentRound === 0) {\r\n    return null;\r\n  }\r\n  \r\n  return gameSession.rounds[gameSession.currentRound - 1];\r\n};\r\nexport const selectGameLoading = (state) => state.game.loading;\r\nexport const selectGameError = (state) => state.game.error;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}