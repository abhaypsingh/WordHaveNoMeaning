{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { v4 as uuidv4 } from 'uuid';\nimport { selectWordsForGame } from '../../services/wordService';\n\n// Initial state\nconst initialState = {\n  gameSession: null,\n  loading: false,\n  error: null\n};\n\n// Async thunks\nexport const initializeGame = createAsyncThunk('game/initializeGame', async (settings, {\n  rejectWithValue\n}) => {\n  try {\n    // Get words for the game based on difficulty and round count\n    const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\n\n    // Create game session\n    const gameSession = {\n      id: uuidv4(),\n      startTime: new Date(),\n      endTime: null,\n      settings,\n      currentRound: 0,\n      totalRounds: settings.roundCount,\n      score: 0,\n      rounds: [],\n      completed: false,\n      encounteredConcepts: []\n    };\n\n    // Create rounds for each selected word\n    const rounds = selectedWords.map((word, index) => {\n      // Generate options for this word\n      const options = generateMeaningOptions(word);\n\n      // Select a contradiction meaning\n      const correctMeaning = selectContradictionMeaning(word, options);\n\n      // Mark the contradiction meaning in the options\n      const markedOptions = options.map(option => ({\n        ...option,\n        isContradiction: option.text === correctMeaning.definition\n      }));\n      return {\n        roundNumber: index + 1,\n        word,\n        correctMeaning,\n        options: markedOptions,\n        selectedOption: null,\n        timeSpent: 0,\n        score: 0,\n        completed: false\n      };\n    });\n\n    // Add rounds to game session\n    gameSession.rounds = rounds;\n    return gameSession;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const startNextRound = createAsyncThunk('game/startNextRound', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n    if (gameSession.currentRound >= gameSession.totalRounds) {\n      throw new Error('No more rounds available');\n    }\n    return gameSession.currentRound + 1;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const processUserSelection = createAsyncThunk('game/processUserSelection', async ({\n  optionIndex,\n  timeSpent\n}, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n    const currentRound = gameSession.rounds[gameSession.currentRound - 1];\n    if (!currentRound) {\n      throw new Error('Invalid round');\n    }\n    const selectedOption = currentRound.options[optionIndex];\n    if (!selectedOption) {\n      throw new Error('Invalid option selected');\n    }\n\n    // Calculate score\n    const baseScore = selectedOption.isCorrect ? 100 : 25;\n    const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\n    const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\n    const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\n    return {\n      roundIndex: gameSession.currentRound - 1,\n      optionIndex,\n      timeSpent,\n      score\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const completeGame = createAsyncThunk('game/completeGame', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n\n    // Calculate final statistics\n    let totalTimeSpent = 0;\n    let correctAnswers = 0;\n    gameSession.rounds.forEach(round => {\n      totalTimeSpent += round.timeSpent;\n      if (round.selectedOption !== null) {\n        const selectedOption = round.options[round.selectedOption];\n        if (selectedOption && selectedOption.isCorrect) {\n          correctAnswers += 1;\n        }\n      }\n    });\n    const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\n    const accuracyRate = correctAnswers / gameSession.totalRounds * 100;\n    return {\n      endTime: new Date(),\n      totalTimeSpent,\n      correctAnswers,\n      averageTimePerRound,\n      accuracyRate\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\n\n// Helper functions\nfunction generateMeaningOptions(word) {\n  // In a real implementation, this would generate options based on the word's meanings\n  // and distractors from the database. For now, we'll create a simplified version.\n\n  // Include actual meanings (up to 3)\n  const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\n  const options = actualMeanings.map((meaning, index) => ({\n    index,\n    text: meaning.definition,\n    isCorrect: true,\n    isContradiction: false\n  }));\n\n  // Fill remaining slots with distractors\n  const neededDistractors = 4 - options.length;\n  if (neededDistractors > 0) {\n    // In a real implementation, these would come from a distractor database\n    const dummyDistractors = [\"To prepare food by heating it in an oven\", \"A small, round fruit with red or green skin\", \"A device used for measuring time\", \"A large, four-legged animal with a trunk\"].slice(0, neededDistractors);\n    dummyDistractors.forEach((distractor, index) => {\n      options.push({\n        index: options.length,\n        text: distractor,\n        isCorrect: false,\n        isContradiction: false\n      });\n    });\n  }\n\n  // Shuffle options\n  return shuffleArray(options);\n}\nfunction selectContradictionMeaning(word, options) {\n  // In a real implementation, this would select a meaning that has contradiction sentences\n  // For now, we'll just pick one of the correct meanings\n\n  const correctOptions = options.filter(option => option.isCorrect);\n  if (correctOptions.length === 0) {\n    // Fallback to any meaning if no correct options\n    return word.meanings[0];\n  }\n  const randomIndex = Math.floor(Math.random() * correctOptions.length);\n  const selectedOption = correctOptions[randomIndex];\n\n  // Find the corresponding meaning\n  return word.meanings.find(meaning => meaning.definition === selectedOption.text) || word.meanings[0];\n}\nfunction calculateTimeBonus(timeSpent, timeLimit) {\n  if (timeLimit === 0) {\n    return 1.0; // No time bonus if no time limit\n  }\n\n  // Calculate bonus factor (1.0 to 1.5)\n  const timeRatio = 1 - timeSpent / timeLimit;\n  const bonus = 1.0 + timeRatio * 0.5;\n\n  // Ensure bonus is within bounds\n  return Math.max(1.0, Math.min(1.5, bonus));\n}\nfunction getDifficultyMultiplier(difficulty) {\n  switch (difficulty) {\n    case 'easy':\n      return 1.0;\n    case 'medium':\n      return 1.25;\n    case 'hard':\n      return 1.5;\n    default:\n      return 1.0;\n  }\n}\nfunction shuffleArray(array) {\n  const result = [...array];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\n\n// Create slice\nconst gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    resetGame: state => {\n      state.gameSession = null;\n      state.loading = false;\n      state.error = null;\n    },\n    restoreSession: (state, action) => {\n      state.gameSession = action.payload;\n      state.loading = false;\n      state.error = null;\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Initialize game\n    .addCase(initializeGame.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(initializeGame.fulfilled, (state, action) => {\n      state.gameSession = action.payload;\n      state.loading = false;\n    }).addCase(initializeGame.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Start next round\n    .addCase(startNextRound.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(startNextRound.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        state.gameSession.currentRound = action.payload;\n      }\n      state.loading = false;\n    }).addCase(startNextRound.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Process user selection\n    .addCase(processUserSelection.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(processUserSelection.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        const {\n          roundIndex,\n          optionIndex,\n          timeSpent,\n          score\n        } = action.payload;\n        const round = state.gameSession.rounds[roundIndex];\n        if (round) {\n          round.selectedOption = optionIndex;\n          round.timeSpent = timeSpent;\n          round.score = score;\n          round.completed = true;\n\n          // Update total score\n          state.gameSession.score += score;\n        }\n      }\n      state.loading = false;\n    }).addCase(processUserSelection.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Complete game\n    .addCase(completeGame.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(completeGame.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        state.gameSession.endTime = action.payload.endTime;\n        state.gameSession.completed = true;\n      }\n      state.loading = false;\n    }).addCase(completeGame.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\n\n// Export actions and reducer\nexport const {\n  resetGame,\n  restoreSession\n} = gameSlice.actions;\nexport default gameSlice.reducer;\n\n// Selectors\nexport const selectGameSession = state => state.game.gameSession;\nexport const selectCurrentRound = state => {\n  const {\n    gameSession\n  } = state.game;\n  if (!gameSession || gameSession.currentRound === 0) {\n    return null;\n  }\n  return gameSession.rounds[gameSession.currentRound - 1];\n};\nexport const selectGameLoading = state => state.game.loading;\nexport const selectGameError = state => state.game.error;","map":{"version":3,"names":["createSlice","createAsyncThunk","v4","uuidv4","selectWordsForGame","initialState","gameSession","loading","error","initializeGame","settings","rejectWithValue","selectedWords","difficulty","roundCount","id","startTime","Date","endTime","currentRound","totalRounds","score","rounds","completed","encounteredConcepts","map","word","index","options","generateMeaningOptions","correctMeaning","selectContradictionMeaning","markedOptions","option","isContradiction","text","definition","roundNumber","selectedOption","timeSpent","message","startNextRound","_","getState","game","Error","processUserSelection","optionIndex","baseScore","isCorrect","timeBonus","calculateTimeBonus","timeLimit","difficultyMultiplier","getDifficultyMultiplier","Math","round","roundIndex","completeGame","totalTimeSpent","correctAnswers","forEach","averageTimePerRound","accuracyRate","actualMeanings","meanings","slice","min","length","meaning","neededDistractors","dummyDistractors","distractor","push","shuffleArray","correctOptions","filter","randomIndex","floor","random","find","timeRatio","bonus","max","array","result","i","j","gameSlice","name","reducers","resetGame","state","restoreSession","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectGameSession","selectCurrentRound","selectGameLoading","selectGameError"],"sources":["C:/Users/abhay/Downloads/WordsEmptyMeaning/src/store/slices/gameSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { selectWordsForGame } from '../../services/wordService';\r\n\r\n// Initial state\r\nconst initialState = {\r\n  gameSession: null,\r\n  loading: false,\r\n  error: null,\r\n};\r\n\r\n// Async thunks\r\nexport const initializeGame = createAsyncThunk(\r\n  'game/initializeGame',\r\n  async (settings, { rejectWithValue }) => {\r\n    try {\r\n      // Get words for the game based on difficulty and round count\r\n      const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\r\n      \r\n      // Create game session\r\n      const gameSession = {\r\n        id: uuidv4(),\r\n        startTime: new Date(),\r\n        endTime: null,\r\n        settings,\r\n        currentRound: 0,\r\n        totalRounds: settings.roundCount,\r\n        score: 0,\r\n        rounds: [],\r\n        completed: false,\r\n        encounteredConcepts: [],\r\n      };\r\n      \r\n      // Create rounds for each selected word\r\n      const rounds = selectedWords.map((word, index) => {\r\n        // Generate options for this word\r\n        const options = generateMeaningOptions(word);\r\n        \r\n        // Select a contradiction meaning\r\n        const correctMeaning = selectContradictionMeaning(word, options);\r\n        \r\n        // Mark the contradiction meaning in the options\r\n        const markedOptions = options.map(option => ({\r\n          ...option,\r\n          isContradiction: option.text === correctMeaning.definition\r\n        }));\r\n        \r\n        return {\r\n          roundNumber: index + 1,\r\n          word,\r\n          correctMeaning,\r\n          options: markedOptions,\r\n          selectedOption: null,\r\n          timeSpent: 0,\r\n          score: 0,\r\n          completed: false,\r\n        };\r\n      });\r\n      \r\n      // Add rounds to game session\r\n      gameSession.rounds = rounds;\r\n      \r\n      return gameSession;\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const startNextRound = createAsyncThunk(\r\n  'game/startNextRound',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      if (!gameSession) {\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      if (gameSession.currentRound >= gameSession.totalRounds) {\r\n        throw new Error('No more rounds available');\r\n      }\r\n      \r\n      return gameSession.currentRound + 1;\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const processUserSelection = createAsyncThunk(\r\n  'game/processUserSelection',\r\n  async ({ optionIndex, timeSpent }, { getState, rejectWithValue }) => {\r\n    try {\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      if (!gameSession) {\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      const currentRound = gameSession.rounds[gameSession.currentRound - 1];\r\n      \r\n      if (!currentRound) {\r\n        throw new Error('Invalid round');\r\n      }\r\n      \r\n      const selectedOption = currentRound.options[optionIndex];\r\n      \r\n      if (!selectedOption) {\r\n        throw new Error('Invalid option selected');\r\n      }\r\n      \r\n      // Calculate score\r\n      const baseScore = selectedOption.isCorrect ? 100 : 25;\r\n      const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\r\n      const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\r\n      \r\n      const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\r\n      \r\n      return {\r\n        roundIndex: gameSession.currentRound - 1,\r\n        optionIndex,\r\n        timeSpent,\r\n        score,\r\n      };\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const completeGame = createAsyncThunk(\r\n  'game/completeGame',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      if (!gameSession) {\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      // Calculate final statistics\r\n      let totalTimeSpent = 0;\r\n      let correctAnswers = 0;\r\n      \r\n      gameSession.rounds.forEach(round => {\r\n        totalTimeSpent += round.timeSpent;\r\n        \r\n        if (round.selectedOption !== null) {\r\n          const selectedOption = round.options[round.selectedOption];\r\n          if (selectedOption && selectedOption.isCorrect) {\r\n            correctAnswers += 1;\r\n          }\r\n        }\r\n      });\r\n      \r\n      const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\r\n      const accuracyRate = (correctAnswers / gameSession.totalRounds) * 100;\r\n      \r\n      return {\r\n        endTime: new Date(),\r\n        totalTimeSpent,\r\n        correctAnswers,\r\n        averageTimePerRound,\r\n        accuracyRate,\r\n      };\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\n// Helper functions\r\nfunction generateMeaningOptions(word) {\r\n  // In a real implementation, this would generate options based on the word's meanings\r\n  // and distractors from the database. For now, we'll create a simplified version.\r\n  \r\n  // Include actual meanings (up to 3)\r\n  const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\r\n  \r\n  const options = actualMeanings.map((meaning, index) => ({\r\n    index,\r\n    text: meaning.definition,\r\n    isCorrect: true,\r\n    isContradiction: false,\r\n  }));\r\n  \r\n  // Fill remaining slots with distractors\r\n  const neededDistractors = 4 - options.length;\r\n  \r\n  if (neededDistractors > 0) {\r\n    // In a real implementation, these would come from a distractor database\r\n    const dummyDistractors = [\r\n      \"To prepare food by heating it in an oven\",\r\n      \"A small, round fruit with red or green skin\",\r\n      \"A device used for measuring time\",\r\n      \"A large, four-legged animal with a trunk\",\r\n    ].slice(0, neededDistractors);\r\n    \r\n    dummyDistractors.forEach((distractor, index) => {\r\n      options.push({\r\n        index: options.length,\r\n        text: distractor,\r\n        isCorrect: false,\r\n        isContradiction: false,\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Shuffle options\r\n  return shuffleArray(options);\r\n}\r\n\r\nfunction selectContradictionMeaning(word, options) {\r\n  // In a real implementation, this would select a meaning that has contradiction sentences\r\n  // For now, we'll just pick one of the correct meanings\r\n  \r\n  const correctOptions = options.filter(option => option.isCorrect);\r\n  \r\n  if (correctOptions.length === 0) {\r\n    // Fallback to any meaning if no correct options\r\n    return word.meanings[0];\r\n  }\r\n  \r\n  const randomIndex = Math.floor(Math.random() * correctOptions.length);\r\n  const selectedOption = correctOptions[randomIndex];\r\n  \r\n  // Find the corresponding meaning\r\n  return word.meanings.find(meaning => meaning.definition === selectedOption.text) || word.meanings[0];\r\n}\r\n\r\nfunction calculateTimeBonus(timeSpent, timeLimit) {\r\n  if (timeLimit === 0) {\r\n    return 1.0; // No time bonus if no time limit\r\n  }\r\n  \r\n  // Calculate bonus factor (1.0 to 1.5)\r\n  const timeRatio = 1 - (timeSpent / timeLimit);\r\n  const bonus = 1.0 + (timeRatio * 0.5);\r\n  \r\n  // Ensure bonus is within bounds\r\n  return Math.max(1.0, Math.min(1.5, bonus));\r\n}\r\n\r\nfunction getDifficultyMultiplier(difficulty) {\r\n  switch (difficulty) {\r\n    case 'easy':\r\n      return 1.0;\r\n    case 'medium':\r\n      return 1.25;\r\n    case 'hard':\r\n      return 1.5;\r\n    default:\r\n      return 1.0;\r\n  }\r\n}\r\n\r\nfunction shuffleArray(array) {\r\n  const result = [...array];\r\n  \r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n// Create slice\r\nconst gameSlice = createSlice({\r\n  name: 'game',\r\n  initialState,\r\n  reducers: {\r\n    resetGame: (state) => {\r\n      state.gameSession = null;\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n    restoreSession: (state, action) => {\r\n      state.gameSession = action.payload;\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Initialize game\r\n      .addCase(initializeGame.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(initializeGame.fulfilled, (state, action) => {\r\n        state.gameSession = action.payload;\r\n        state.loading = false;\r\n      })\r\n      .addCase(initializeGame.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Start next round\r\n      .addCase(startNextRound.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(startNextRound.fulfilled, (state, action) => {\r\n        if (state.gameSession) {\r\n          state.gameSession.currentRound = action.payload;\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(startNextRound.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Process user selection\r\n      .addCase(processUserSelection.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(processUserSelection.fulfilled, (state, action) => {\r\n        if (state.gameSession) {\r\n          const { roundIndex, optionIndex, timeSpent, score } = action.payload;\r\n          const round = state.gameSession.rounds[roundIndex];\r\n          \r\n          if (round) {\r\n            round.selectedOption = optionIndex;\r\n            round.timeSpent = timeSpent;\r\n            round.score = score;\r\n            round.completed = true;\r\n            \r\n            // Update total score\r\n            state.gameSession.score += score;\r\n          }\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(processUserSelection.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Complete game\r\n      .addCase(completeGame.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(completeGame.fulfilled, (state, action) => {\r\n        if (state.gameSession) {\r\n          state.gameSession.endTime = action.payload.endTime;\r\n          state.gameSession.completed = true;\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(completeGame.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      });\r\n  },\r\n});\r\n\r\n// Export actions and reducer\r\nexport const { resetGame, restoreSession } = gameSlice.actions;\r\nexport default gameSlice.reducer;\r\n\r\n// Selectors\r\nexport const selectGameSession = (state) => state.game.gameSession;\r\nexport const selectCurrentRound = (state) => {\r\n  const { gameSession } = state.game;\r\n  \r\n  if (!gameSession || gameSession.currentRound === 0) {\r\n    return null;\r\n  }\r\n  \r\n  return gameSession.rounds[gameSession.currentRound - 1];\r\n};\r\nexport const selectGameLoading = (state) => state.game.loading;\r\nexport const selectGameError = (state) => state.game.error;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}