{"ast":null,"code":"import { educationalMessages, linguisticConcepts, educationalTakeaways } from '../data/educationalContent';\n\n/**\r\n * Gets an educational message relevant to a word and its meanings\r\n * @param {Object} word - The word object\r\n * @param {Object} selectedMeaning - The meaning selected by the user\r\n * @param {Object} contradictionMeaning - The meaning used for contradiction\r\n * @returns {Promise<Object>} - A promise that resolves to an educational message\r\n */\nexport const getEducationalMessage = async (word, selectedMeaning, contradictionMeaning) => {\n  try {\n    // Identify the linguistic concept demonstrated by this contradiction\n    const concept = identifyLinguisticConcept(word, selectedMeaning, contradictionMeaning);\n\n    // Get messages relevant to this concept\n    let relevantMessages = educationalMessages.filter(message => message.category === concept || message.relatedWords.includes(word.text));\n\n    // If no specific messages, get generic ones about context and meaning\n    if (relevantMessages.length === 0) {\n      relevantMessages = educationalMessages.filter(message => message.category === 'context' || message.category === 'meaning');\n    }\n\n    // Filter to appropriate difficulty\n    let filteredMessages = relevantMessages.filter(message => message.difficulty === word.difficulty);\n\n    // If none at right difficulty, use any relevant message\n    if (filteredMessages.length === 0) {\n      filteredMessages = relevantMessages;\n    }\n\n    // Select a random message\n    const randomIndex = Math.floor(Math.random() * filteredMessages.length);\n    const selectedMessage = filteredMessages[randomIndex] || {\n      id: 'default_message',\n      text: 'Words have no inherent meaning without context. The same word can have completely different meanings depending on how it\\'s used.',\n      category: 'context',\n      difficulty: 'medium',\n      relatedWords: []\n    };\n    return selectedMessage;\n  } catch (error) {\n    console.error('Error getting educational message:', error);\n    throw new Error('Failed to get educational message');\n  }\n};\n\n/**\r\n * Gets an explanation for a linguistic concept\r\n * @param {string} conceptId - The ID of the concept to explain\r\n * @returns {Promise<Object>} - A promise that resolves to a concept explanation\r\n */\nexport const getConceptExplanation = async conceptId => {\n  try {\n    const concept = linguisticConcepts.find(c => c.id === conceptId);\n    if (!concept) {\n      throw new Error(`Concept with ID ${conceptId} not found`);\n    }\n    return concept;\n  } catch (error) {\n    console.error('Error getting concept explanation:', error);\n    throw new Error('Failed to get concept explanation');\n  }\n};\n\n/**\r\n * Generates educational takeaways based on encountered concepts\r\n * @param {Array} encounteredConcepts - Array of concept IDs encountered during gameplay\r\n * @returns {Promise<Array>} - A promise that resolves to an array of takeaways\r\n */\nexport const getGameTakeaways = async encounteredConcepts => {\n  try {\n    // Add general takeaway about context and meaning\n    const takeaways = [\"Words have no inherent meaning without context. The same word can have completely different meanings depending on how it's used.\"];\n\n    // Add specific takeaways for each encountered concept\n    if (encounteredConcepts && encounteredConcepts.length > 0) {\n      for (const conceptId of encounteredConcepts) {\n        const relevantTakeaways = educationalTakeaways.filter(takeaway => takeaway.conceptId === conceptId);\n        if (relevantTakeaways.length > 0) {\n          // Add one takeaway per concept\n          const randomIndex = Math.floor(Math.random() * relevantTakeaways.length);\n          takeaways.push(relevantTakeaways[randomIndex].text);\n        }\n      }\n    } else {\n      // If no specific concepts encountered, add some general takeaways\n      const generalTakeaways = [\"Homonyms are words that sound the same but have different meanings, often with different etymological origins.\", \"Polysemes are words with multiple related meanings that evolved from the same original concept.\", \"Context is the primary determinant of meaning in language, which is why isolated words can be ambiguous or misleading.\"];\n      takeaways.push(...generalTakeaways);\n    }\n    return takeaways;\n  } catch (error) {\n    console.error('Error generating takeaways:', error);\n    throw new Error('Failed to generate educational takeaways');\n  }\n};\n\n/**\r\n * Identifies the linguistic concept demonstrated by a word and its meanings\r\n * @param {Object} word - The word object\r\n * @param {Object} selectedMeaning - The meaning selected by the user\r\n * @param {Object} contradictionMeaning - The meaning used for contradiction\r\n * @returns {string} - The identified concept\r\n */\nfunction identifyLinguisticConcept(word, selectedMeaning, contradictionMeaning) {\n  // Check if the word has specific categories that indicate a concept\n  if (word.categories.includes('homonym')) {\n    return 'homonym';\n  } else if (word.categories.includes('polyseme')) {\n    return 'polyseme';\n  } else if (word.categories.includes('metonymy')) {\n    return 'metonymy';\n  } else if (word.categories.includes('semantic_shift')) {\n    return 'semantic_shift';\n  }\n\n  // If no specific category, determine based on the relationship between meanings\n  if (selectedMeaning && contradictionMeaning) {\n    if (selectedMeaning.partOfSpeech !== contradictionMeaning.partOfSpeech) {\n      return 'part_of_speech_variation';\n    }\n\n    // Check if one meaning is archaic\n    if (selectedMeaning.isArchaic !== contradictionMeaning.isArchaic) {\n      return 'semantic_shift';\n    }\n  }\n\n  // Default to context dependency\n  return 'context_dependency';\n}\n\n/**\r\n * Determines the user's current learning stage based on game progress\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<string>} - A promise that resolves to the learning stage\r\n */\nexport const determineUserLearningStage = async gameSession => {\n  try {\n    if (!gameSession) {\n      return 'introduction';\n    }\n    const {\n      currentRound,\n      totalRounds,\n      _encounteredConcepts\n    } = gameSession;\n\n    // Simple progression based on game completion percentage\n    const completionPercentage = currentRound / totalRounds * 100;\n    if (completionPercentage < 20) {\n      return 'introduction';\n    } else if (completionPercentage < 40) {\n      return 'exploration';\n    } else if (completionPercentage < 60) {\n      return 'contradiction';\n    } else if (completionPercentage < 80) {\n      return 'conceptualization';\n    } else if (completionPercentage < 100) {\n      return 'application';\n    } else {\n      return 'synthesis';\n    }\n  } catch (error) {\n    console.error('Error determining learning stage:', error);\n    throw new Error('Failed to determine learning stage');\n  }\n};\n\n/**\r\n * Records a concept exposure for spaced repetition\r\n * @param {string} conceptId - The ID of the concept exposed\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<void>} - A promise that resolves when the exposure is recorded\r\n */\nexport const recordConceptExposure = async (conceptId, gameSession) => {\n  try {\n    // In a real implementation, this would update a database or state\n    // For now, we'll just log it\n\n    // Add to encountered concepts if not already present\n    if (gameSession && gameSession.encounteredConcepts && !gameSession.encounteredConcepts.includes(conceptId)) {\n      gameSession.encounteredConcepts.push(conceptId);\n    }\n  } catch (error) {\n    console.error('Error recording concept exposure:', error);\n    throw new Error('Failed to record concept exposure');\n  }\n};","map":{"version":3,"names":["educationalMessages","linguisticConcepts","educationalTakeaways","getEducationalMessage","word","selectedMeaning","contradictionMeaning","concept","identifyLinguisticConcept","relevantMessages","filter","message","category","relatedWords","includes","text","length","filteredMessages","difficulty","randomIndex","Math","floor","random","selectedMessage","id","error","console","Error","getConceptExplanation","conceptId","find","c","getGameTakeaways","encounteredConcepts","takeaways","relevantTakeaways","takeaway","push","generalTakeaways","categories","partOfSpeech","isArchaic","determineUserLearningStage","gameSession","currentRound","totalRounds","_encounteredConcepts","completionPercentage","recordConceptExposure"],"sources":["C:/Users/abhay/Downloads/WordHaveNoMeaning/src/services/educationalService.js"],"sourcesContent":["import { educationalMessages, linguisticConcepts, educationalTakeaways } from '../data/educationalContent';\r\n\r\n/**\r\n * Gets an educational message relevant to a word and its meanings\r\n * @param {Object} word - The word object\r\n * @param {Object} selectedMeaning - The meaning selected by the user\r\n * @param {Object} contradictionMeaning - The meaning used for contradiction\r\n * @returns {Promise<Object>} - A promise that resolves to an educational message\r\n */\r\nexport const getEducationalMessage = async (word, selectedMeaning, contradictionMeaning) => {\r\n  try {\r\n    // Identify the linguistic concept demonstrated by this contradiction\r\n    const concept = identifyLinguisticConcept(word, selectedMeaning, contradictionMeaning);\r\n    \r\n    // Get messages relevant to this concept\r\n    let relevantMessages = educationalMessages.filter(message => \r\n      message.category === concept || message.relatedWords.includes(word.text)\r\n    );\r\n    \r\n    // If no specific messages, get generic ones about context and meaning\r\n    if (relevantMessages.length === 0) {\r\n      relevantMessages = educationalMessages.filter(message => \r\n        message.category === 'context' || message.category === 'meaning'\r\n      );\r\n    }\r\n    \r\n    // Filter to appropriate difficulty\r\n    let filteredMessages = relevantMessages.filter(message => \r\n      message.difficulty === word.difficulty\r\n    );\r\n    \r\n    // If none at right difficulty, use any relevant message\r\n    if (filteredMessages.length === 0) {\r\n      filteredMessages = relevantMessages;\r\n    }\r\n    \r\n    // Select a random message\r\n    const randomIndex = Math.floor(Math.random() * filteredMessages.length);\r\n    const selectedMessage = filteredMessages[randomIndex] || {\r\n      id: 'default_message',\r\n      text: 'Words have no inherent meaning without context. The same word can have completely different meanings depending on how it\\'s used.',\r\n      category: 'context',\r\n      difficulty: 'medium',\r\n      relatedWords: []\r\n    };\r\n    \r\n    return selectedMessage;\r\n  } catch (error) {\r\n    console.error('Error getting educational message:', error);\r\n    throw new Error('Failed to get educational message');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets an explanation for a linguistic concept\r\n * @param {string} conceptId - The ID of the concept to explain\r\n * @returns {Promise<Object>} - A promise that resolves to a concept explanation\r\n */\r\nexport const getConceptExplanation = async (conceptId) => {\r\n  try {\r\n    const concept = linguisticConcepts.find(c => c.id === conceptId);\r\n    \r\n    if (!concept) {\r\n      throw new Error(`Concept with ID ${conceptId} not found`);\r\n    }\r\n    \r\n    return concept;\r\n  } catch (error) {\r\n    console.error('Error getting concept explanation:', error);\r\n    throw new Error('Failed to get concept explanation');\r\n  }\r\n};\r\n\r\n/**\r\n * Generates educational takeaways based on encountered concepts\r\n * @param {Array} encounteredConcepts - Array of concept IDs encountered during gameplay\r\n * @returns {Promise<Array>} - A promise that resolves to an array of takeaways\r\n */\r\nexport const getGameTakeaways = async (encounteredConcepts) => {\r\n  try {\r\n    // Add general takeaway about context and meaning\r\n    const takeaways = [\r\n      \"Words have no inherent meaning without context. The same word can have completely different meanings depending on how it's used.\"\r\n    ];\r\n    \r\n    // Add specific takeaways for each encountered concept\r\n    if (encounteredConcepts && encounteredConcepts.length > 0) {\r\n      for (const conceptId of encounteredConcepts) {\r\n        const relevantTakeaways = educationalTakeaways.filter(takeaway => \r\n          takeaway.conceptId === conceptId\r\n        );\r\n        \r\n        if (relevantTakeaways.length > 0) {\r\n          // Add one takeaway per concept\r\n          const randomIndex = Math.floor(Math.random() * relevantTakeaways.length);\r\n          takeaways.push(relevantTakeaways[randomIndex].text);\r\n        }\r\n      }\r\n    } else {\r\n      // If no specific concepts encountered, add some general takeaways\r\n      const generalTakeaways = [\r\n        \"Homonyms are words that sound the same but have different meanings, often with different etymological origins.\",\r\n        \"Polysemes are words with multiple related meanings that evolved from the same original concept.\",\r\n        \"Context is the primary determinant of meaning in language, which is why isolated words can be ambiguous or misleading.\"\r\n      ];\r\n      \r\n      takeaways.push(...generalTakeaways);\r\n    }\r\n    \r\n    return takeaways;\r\n  } catch (error) {\r\n    console.error('Error generating takeaways:', error);\r\n    throw new Error('Failed to generate educational takeaways');\r\n  }\r\n};\r\n\r\n/**\r\n * Identifies the linguistic concept demonstrated by a word and its meanings\r\n * @param {Object} word - The word object\r\n * @param {Object} selectedMeaning - The meaning selected by the user\r\n * @param {Object} contradictionMeaning - The meaning used for contradiction\r\n * @returns {string} - The identified concept\r\n */\r\nfunction identifyLinguisticConcept(word, selectedMeaning, contradictionMeaning) {\r\n  // Check if the word has specific categories that indicate a concept\r\n  if (word.categories.includes('homonym')) {\r\n    return 'homonym';\r\n  } else if (word.categories.includes('polyseme')) {\r\n    return 'polyseme';\r\n  } else if (word.categories.includes('metonymy')) {\r\n    return 'metonymy';\r\n  } else if (word.categories.includes('semantic_shift')) {\r\n    return 'semantic_shift';\r\n  }\r\n  \r\n  // If no specific category, determine based on the relationship between meanings\r\n  if (selectedMeaning && contradictionMeaning) {\r\n    if (selectedMeaning.partOfSpeech !== contradictionMeaning.partOfSpeech) {\r\n      return 'part_of_speech_variation';\r\n    }\r\n    \r\n    // Check if one meaning is archaic\r\n    if (selectedMeaning.isArchaic !== contradictionMeaning.isArchaic) {\r\n      return 'semantic_shift';\r\n    }\r\n  }\r\n  \r\n  // Default to context dependency\r\n  return 'context_dependency';\r\n}\r\n\r\n/**\r\n * Determines the user's current learning stage based on game progress\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<string>} - A promise that resolves to the learning stage\r\n */\r\nexport const determineUserLearningStage = async (gameSession) => {\r\n  try {\r\n    if (!gameSession) {\r\n      return 'introduction';\r\n    }\r\n    \r\n    const { currentRound, totalRounds, _encounteredConcepts } = gameSession;\r\n    \r\n    // Simple progression based on game completion percentage\r\n    const completionPercentage = (currentRound / totalRounds) * 100;\r\n    \r\n    if (completionPercentage < 20) {\r\n      return 'introduction';\r\n    } else if (completionPercentage < 40) {\r\n      return 'exploration';\r\n    } else if (completionPercentage < 60) {\r\n      return 'contradiction';\r\n    } else if (completionPercentage < 80) {\r\n      return 'conceptualization';\r\n    } else if (completionPercentage < 100) {\r\n      return 'application';\r\n    } else {\r\n      return 'synthesis';\r\n    }\r\n  } catch (error) {\r\n    console.error('Error determining learning stage:', error);\r\n    throw new Error('Failed to determine learning stage');\r\n  }\r\n};\r\n\r\n/**\r\n * Records a concept exposure for spaced repetition\r\n * @param {string} conceptId - The ID of the concept exposed\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<void>} - A promise that resolves when the exposure is recorded\r\n */\r\nexport const recordConceptExposure = async (conceptId, gameSession) => {\r\n  try {\r\n    // In a real implementation, this would update a database or state\r\n    // For now, we'll just log it\r\n    \r\n    \r\n    // Add to encountered concepts if not already present\r\n    if (gameSession && gameSession.encounteredConcepts && !gameSession.encounteredConcepts.includes(conceptId)) {\r\n      gameSession.encounteredConcepts.push(conceptId);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error recording concept exposure:', error);\r\n    throw new Error('Failed to record concept exposure');\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}