{"ast":null,"code":"/**\r\n * Storage Management Service\r\n * \r\n * This service provides utilities for managing localStorage usage,\r\n * preventing storage limits from being reached, and optimizing storage.\r\n */\n\n// Constants\nconst MAX_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB (typical localStorage limit)\nconst STORAGE_WARNING_THRESHOLD = 0.8; // 80% of max storage\nconst MAX_COMPLETED_GAMES = 20; // Maximum number of completed games to store\n\n/**\r\n * Checks the current localStorage usage\r\n * @returns {Object} - Object containing usage information\r\n */\nexport const checkStorageUsage = () => {\n  try {\n    let totalSize = 0;\n    let itemCount = 0;\n    let largestItem = {\n      key: null,\n      size: 0\n    };\n\n    // Calculate size of all items\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      const value = localStorage.getItem(key);\n      const size = new Blob([value]).size;\n      totalSize += size;\n      itemCount++;\n      if (size > largestItem.size) {\n        largestItem = {\n          key,\n          size\n        };\n      }\n    }\n    return {\n      totalSize,\n      percentUsed: totalSize / MAX_STORAGE_SIZE,\n      itemCount,\n      largestItem,\n      isNearLimit: totalSize > STORAGE_WARNING_THRESHOLD * MAX_STORAGE_SIZE\n    };\n  } catch (error) {\n    console.error('Error checking storage usage:', error);\n    return {\n      totalSize: 0,\n      percentUsed: 0,\n      itemCount: 0,\n      largestItem: {\n        key: null,\n        size: 0\n      },\n      isNearLimit: false,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Optimizes storage by removing oldest completed games if near limit\r\n * @returns {boolean} - True if optimization was performed, false otherwise\r\n */\nexport const optimizeStorage = () => {\n  try {\n    const usage = checkStorageUsage();\n\n    // If we're near the limit, perform optimization\n    if (usage.isNearLimit) {\n      const completedGamesKey = 'words_without_meaning_completed_games';\n      const completedGamesStr = localStorage.getItem(completedGamesKey);\n      if (completedGamesStr) {\n        let completedGames = JSON.parse(completedGamesStr);\n        if (Array.isArray(completedGames) && completedGames.length > MAX_COMPLETED_GAMES) {\n          // Sort by date (newest first)\n          completedGames.sort((a, b) => {\n            const dateA = a.endTime ? new Date(a.endTime) : new Date(0);\n            const dateB = b.endTime ? new Date(b.endTime) : new Date(0);\n            return dateB - dateA;\n          });\n\n          // Keep only the most recent games\n          const trimmedGames = completedGames.slice(0, MAX_COMPLETED_GAMES);\n\n          // Save back to storage\n          localStorage.setItem(completedGamesKey, JSON.stringify(trimmedGames));\n          return true;\n        }\n      }\n    }\n    return false;\n  } catch (error) {\n    console.error('Error optimizing storage:', error);\n    return false;\n  }\n};\n\n/**\r\n * Cleans up old or corrupted data\r\n * @returns {boolean} - True if cleanup was performed, false otherwise\r\n */\nexport const cleanupStorage = () => {\n  try {\n    // Remove any backup files older than 7 days\n    const now = new Date();\n    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n\n    // Find all backup keys\n    const backupKeys = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.endsWith('_backup')) {\n        backupKeys.push(key);\n      }\n    }\n\n    // Check each backup for age\n    let cleanupPerformed = false;\n    backupKeys.forEach(key => {\n      const value = localStorage.getItem(key);\n      if (value) {\n        try {\n          const data = JSON.parse(value);\n          if (data.lastSaved) {\n            const savedDate = new Date(data.lastSaved);\n            if (savedDate < sevenDaysAgo) {\n              localStorage.removeItem(key);\n              cleanupPerformed = true;\n            }\n          }\n        } catch (e) {\n          // If we can't parse it, it's corrupted, so remove it\n          localStorage.removeItem(key);\n          cleanupPerformed = true;\n        }\n      }\n    });\n    return cleanupPerformed;\n  } catch (error) {\n    console.error('Error cleaning up storage:', error);\n    return false;\n  }\n};\n\n/**\r\n * Performs a full storage management cycle\r\n * @returns {Object} - Results of the management operations\r\n */\nexport const manageStorage = () => {\n  try {\n    const initialUsage = checkStorageUsage();\n    const optimized = optimizeStorage();\n    const cleaned = cleanupStorage();\n    const finalUsage = checkStorageUsage();\n    return {\n      initialUsage,\n      finalUsage,\n      optimized,\n      cleaned,\n      spaceFreed: initialUsage.totalSize - finalUsage.totalSize\n    };\n  } catch (error) {\n    console.error('Error managing storage:', error);\n    return {\n      error: error.message,\n      initialUsage: null,\n      finalUsage: null,\n      optimized: false,\n      cleaned: false,\n      spaceFreed: 0\n    };\n  }\n};","map":{"version":3,"names":["MAX_STORAGE_SIZE","STORAGE_WARNING_THRESHOLD","MAX_COMPLETED_GAMES","checkStorageUsage","totalSize","itemCount","largestItem","key","size","i","localStorage","length","value","getItem","Blob","percentUsed","isNearLimit","error","console","message","optimizeStorage","usage","completedGamesKey","completedGamesStr","completedGames","JSON","parse","Array","isArray","sort","a","b","dateA","endTime","Date","dateB","trimmedGames","slice","setItem","stringify","cleanupStorage","now","sevenDaysAgo","getTime","backupKeys","endsWith","push","cleanupPerformed","forEach","data","lastSaved","savedDate","removeItem","e","manageStorage","initialUsage","optimized","cleaned","finalUsage","spaceFreed"],"sources":["C:/Users/abhay/Downloads/WordHaveNoMeaning/src/services/storageManagementService.js"],"sourcesContent":["/**\r\n * Storage Management Service\r\n * \r\n * This service provides utilities for managing localStorage usage,\r\n * preventing storage limits from being reached, and optimizing storage.\r\n */\r\n\r\n// Constants\r\nconst MAX_STORAGE_SIZE = 5 * 1024 * 1024; // 5MB (typical localStorage limit)\r\nconst STORAGE_WARNING_THRESHOLD = 0.8; // 80% of max storage\r\nconst MAX_COMPLETED_GAMES = 20; // Maximum number of completed games to store\r\n\r\n/**\r\n * Checks the current localStorage usage\r\n * @returns {Object} - Object containing usage information\r\n */\r\nexport const checkStorageUsage = () => {\r\n  try {\r\n    let totalSize = 0;\r\n    let itemCount = 0;\r\n    let largestItem = { key: null, size: 0 };\r\n    \r\n    // Calculate size of all items\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      const value = localStorage.getItem(key);\r\n      const size = new Blob([value]).size;\r\n      \r\n      totalSize += size;\r\n      itemCount++;\r\n      \r\n      if (size > largestItem.size) {\r\n        largestItem = { key, size };\r\n      }\r\n    }\r\n    \r\n    return {\r\n      totalSize,\r\n      percentUsed: totalSize / MAX_STORAGE_SIZE,\r\n      itemCount,\r\n      largestItem,\r\n      isNearLimit: totalSize > (STORAGE_WARNING_THRESHOLD * MAX_STORAGE_SIZE),\r\n    };\r\n  } catch (error) {\r\n    console.error('Error checking storage usage:', error);\r\n    return {\r\n      totalSize: 0,\r\n      percentUsed: 0,\r\n      itemCount: 0,\r\n      largestItem: { key: null, size: 0 },\r\n      isNearLimit: false,\r\n      error: error.message,\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Optimizes storage by removing oldest completed games if near limit\r\n * @returns {boolean} - True if optimization was performed, false otherwise\r\n */\r\nexport const optimizeStorage = () => {\r\n  try {\r\n    const usage = checkStorageUsage();\r\n    \r\n    // If we're near the limit, perform optimization\r\n    if (usage.isNearLimit) {\r\n      const completedGamesKey = 'words_without_meaning_completed_games';\r\n      const completedGamesStr = localStorage.getItem(completedGamesKey);\r\n      \r\n      if (completedGamesStr) {\r\n        let completedGames = JSON.parse(completedGamesStr);\r\n        \r\n        if (Array.isArray(completedGames) && completedGames.length > MAX_COMPLETED_GAMES) {\r\n          // Sort by date (newest first)\r\n          completedGames.sort((a, b) => {\r\n            const dateA = a.endTime ? new Date(a.endTime) : new Date(0);\r\n            const dateB = b.endTime ? new Date(b.endTime) : new Date(0);\r\n            return dateB - dateA;\r\n          });\r\n          \r\n          // Keep only the most recent games\r\n          const trimmedGames = completedGames.slice(0, MAX_COMPLETED_GAMES);\r\n          \r\n          // Save back to storage\r\n          localStorage.setItem(completedGamesKey, JSON.stringify(trimmedGames));\r\n          \r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error optimizing storage:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Cleans up old or corrupted data\r\n * @returns {boolean} - True if cleanup was performed, false otherwise\r\n */\r\nexport const cleanupStorage = () => {\r\n  try {\r\n    // Remove any backup files older than 7 days\r\n    const now = new Date();\r\n    const sevenDaysAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));\r\n    \r\n    // Find all backup keys\r\n    const backupKeys = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key.endsWith('_backup')) {\r\n        backupKeys.push(key);\r\n      }\r\n    }\r\n    \r\n    // Check each backup for age\r\n    let cleanupPerformed = false;\r\n    backupKeys.forEach(key => {\r\n      const value = localStorage.getItem(key);\r\n      if (value) {\r\n        try {\r\n          const data = JSON.parse(value);\r\n          if (data.lastSaved) {\r\n            const savedDate = new Date(data.lastSaved);\r\n            if (savedDate < sevenDaysAgo) {\r\n              localStorage.removeItem(key);\r\n              cleanupPerformed = true;\r\n            }\r\n          }\r\n        } catch (e) {\r\n          // If we can't parse it, it's corrupted, so remove it\r\n          localStorage.removeItem(key);\r\n          cleanupPerformed = true;\r\n        }\r\n      }\r\n    });\r\n    \r\n    return cleanupPerformed;\r\n  } catch (error) {\r\n    console.error('Error cleaning up storage:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Performs a full storage management cycle\r\n * @returns {Object} - Results of the management operations\r\n */\r\nexport const manageStorage = () => {\r\n  try {\r\n    const initialUsage = checkStorageUsage();\r\n    const optimized = optimizeStorage();\r\n    const cleaned = cleanupStorage();\r\n    const finalUsage = checkStorageUsage();\r\n    \r\n    return {\r\n      initialUsage,\r\n      finalUsage,\r\n      optimized,\r\n      cleaned,\r\n      spaceFreed: initialUsage.totalSize - finalUsage.totalSize,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error managing storage:', error);\r\n    return {\r\n      error: error.message,\r\n      initialUsage: null,\r\n      finalUsage: null,\r\n      optimized: false,\r\n      cleaned: false,\r\n      spaceFreed: 0,\r\n    };\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}