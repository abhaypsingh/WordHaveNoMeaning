{"ast":null,"code":"import { v4 as uuidv4 } from 'uuid';\nimport { selectWordsForGame, getDistractorsForWord } from './wordService';\nimport { recordConceptExposure } from './educationalService';\n\n/**\r\n * Initializes a new game session\r\n * @param {Object} settings - Game settings (difficulty, roundCount, timeLimit, soundEnabled)\r\n * @returns {Promise<Object>} - A promise that resolves to a new game session\r\n */\nexport const initializeGame = async settings => {\n  try {\n    // Get words for the game based on difficulty and round count\n    const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\n\n    // Create game session\n    const gameSession = {\n      id: uuidv4(),\n      startTime: new Date(),\n      endTime: null,\n      settings,\n      currentRound: 0,\n      totalRounds: settings.roundCount,\n      score: 0,\n      rounds: [],\n      completed: false,\n      encounteredConcepts: []\n    };\n\n    // Create rounds for each selected word\n    const rounds = await Promise.all(selectedWords.map(async (word, index) => {\n      // Generate options for this word\n      const options = await generateMeaningOptions(word);\n\n      // Select a contradiction meaning\n      const correctMeaning = selectContradictionMeaning(word, options);\n\n      // Mark the contradiction meaning in the options\n      const markedOptions = options.map(option => ({\n        ...option,\n        isContradiction: option.text === correctMeaning.definition\n      }));\n      return {\n        roundNumber: index + 1,\n        word,\n        correctMeaning,\n        options: markedOptions,\n        selectedOption: null,\n        timeSpent: 0,\n        score: 0,\n        completed: false\n      };\n    }));\n\n    // Add rounds to game session\n    gameSession.rounds = rounds;\n    return gameSession;\n  } catch (error) {\n    console.error('Error initializing game:', error);\n    throw new Error('Failed to initialize game');\n  }\n};\n\n/**\r\n * Starts the next round in a game session\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<boolean>} - A promise that resolves to true if successful, false if no more rounds\r\n */\nexport const startNextRound = async gameSession => {\n  try {\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n    if (gameSession.currentRound >= gameSession.totalRounds) {\n      return false; // No more rounds\n    }\n    gameSession.currentRound += 1;\n    const currentRound = gameSession.rounds[gameSession.currentRound - 1];\n\n    // Reset round state for new round\n    if (currentRound) {\n      currentRound.selectedOption = null;\n      currentRound.timeSpent = 0;\n      currentRound.score = 0;\n      currentRound.completed = false;\n    }\n    return true; // Successfully started next round\n  } catch (error) {\n    console.error('Error starting next round:', error);\n    throw new Error('Failed to start next round');\n  }\n};\n\n/**\r\n * Gets the current round from a game session\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Object|null} - The current round or null if no active round\r\n */\nexport const getCurrentRound = gameSession => {\n  if (!gameSession || gameSession.currentRound === 0 || gameSession.currentRound > gameSession.totalRounds) {\n    return null;\n  }\n  return gameSession.rounds[gameSession.currentRound - 1];\n};\n\n/**\r\n * Processes a user's selection in the current round\r\n * @param {Object} gameSession - The current game session\r\n * @param {number} optionIndex - The index of the selected option\r\n * @param {number} timeSpent - The time spent on this round\r\n * @returns {Promise<Object>} - A promise that resolves to the updated round\r\n */\nexport const processUserSelection = async (gameSession, optionIndex, timeSpent) => {\n  try {\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n    const currentRound = getCurrentRound(gameSession);\n    if (!currentRound) {\n      throw new Error('No active round');\n    }\n    if (currentRound.completed) {\n      throw new Error('Round already completed');\n    }\n\n    // Record user's selection\n    currentRound.selectedOption = optionIndex;\n    currentRound.timeSpent = timeSpent;\n    const selectedOption = currentRound.options[optionIndex];\n    if (!selectedOption) {\n      throw new Error('Invalid option selected');\n    }\n\n    // Calculate score\n    const baseScore = calculateBaseScore(selectedOption.isCorrect);\n    const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\n    const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\n    const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\n    currentRound.score = score;\n\n    // Update total score\n    gameSession.score += score;\n\n    // Mark round as completed\n    currentRound.completed = true;\n\n    // Record concept exposure\n    if (currentRound.word.categories.length > 0) {\n      // Use the first category as a concept for now\n      // In a real implementation, this would be more sophisticated\n      const conceptId = currentRound.word.categories[0];\n      await recordConceptExposure(conceptId, gameSession);\n    }\n    return currentRound;\n  } catch (error) {\n    console.error('Error processing user selection:', error);\n    throw new Error('Failed to process user selection');\n  }\n};\n\n/**\r\n * Gets a contradiction sentence for the current round\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<Object>} - A promise that resolves to contradiction data\r\n */\nexport const getContradictionSentence = async gameSession => {\n  try {\n    const currentRound = getCurrentRound(gameSession);\n    if (!currentRound || !currentRound.completed) {\n      throw new Error('No completed round to get contradiction for');\n    }\n\n    // Get the contradiction meaning\n    const contradictionMeaning = currentRound.correctMeaning;\n\n    // Get a random contradiction sentence\n    const sentences = contradictionMeaning.contradictionSentences;\n    const randomIndex = Math.floor(Math.random() * sentences.length);\n    const selectedSentence = sentences[randomIndex];\n\n    // Create highlighted sentence by wrapping the word in a span\n    const word = currentRound.word.text;\n    const regex = new RegExp(`\\\\b${word}\\\\b`, 'i');\n    const highlightedSentence = selectedSentence.replace(regex, `<span class=\"highlight\">${word}</span>`);\n    return {\n      sentence: selectedSentence,\n      highlightedSentence,\n      meaning: contradictionMeaning.definition,\n      explanation: `In this context, \"${word}\" means \"${contradictionMeaning.definition}\" rather than the meaning you selected.`\n    };\n  } catch (error) {\n    console.error('Error getting contradiction sentence:', error);\n    throw new Error('Failed to get contradiction sentence');\n  }\n};\n\n/**\r\n * Completes a game session and calculates final results\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<Object>} - A promise that resolves to the game results\r\n */\nexport const completeGame = async gameSession => {\n  try {\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n    if (gameSession.completed) {\n      throw new Error('Game already completed');\n    }\n\n    // Set end time and mark as completed\n    gameSession.endTime = new Date();\n    gameSession.completed = true;\n\n    // Calculate final statistics\n    let totalTimeSpent = 0;\n    let correctAnswers = 0;\n    gameSession.rounds.forEach(round => {\n      totalTimeSpent += round.timeSpent;\n      if (round.selectedOption !== null) {\n        const selectedOption = round.options[round.selectedOption];\n        if (selectedOption && selectedOption.isCorrect) {\n          correctAnswers += 1;\n        }\n      }\n    });\n    const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\n    const accuracyRate = correctAnswers / gameSession.totalRounds * 100;\n\n    // Generate performance feedback\n    const performance = generatePerformanceFeedback(accuracyRate);\n\n    // Generate next difficulty suggestion\n    const suggestion = suggestNextDifficulty(gameSession, accuracyRate);\n    return {\n      score: gameSession.score,\n      totalRounds: gameSession.totalRounds,\n      correctAnswers,\n      accuracyRate,\n      averageTimePerRound,\n      difficulty: gameSession.settings.difficulty,\n      performance,\n      suggestion\n    };\n  } catch (error) {\n    console.error('Error completing game:', error);\n    throw new Error('Failed to complete game');\n  }\n};\n\n/**\r\n * Generates meaning options for a word\r\n * @param {Object} word - The word to generate options for\r\n * @returns {Promise<Array>} - A promise that resolves to an array of options\r\n */\nasync function generateMeaningOptions(word) {\n  try {\n    // Include actual meanings (up to 3)\n    const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\n    const options = actualMeanings.map((meaning, index) => ({\n      index,\n      text: meaning.definition,\n      isCorrect: true,\n      isContradiction: false\n    }));\n\n    // Fill remaining slots with distractors\n    const neededDistractors = 4 - options.length;\n    if (neededDistractors > 0) {\n      const distractors = await getDistractorsForWord(word, neededDistractors);\n      distractors.forEach((distractor, _index) => {\n        options.push({\n          index: options.length,\n          text: distractor.definition,\n          isCorrect: false,\n          isContradiction: false\n        });\n      });\n    }\n\n    // Shuffle options\n    return shuffleArray(options);\n  } catch (error) {\n    console.error('Error generating meaning options:', error);\n    throw new Error('Failed to generate meaning options');\n  }\n}\n\n/**\r\n * Selects a contradiction meaning for a word\r\n * @param {Object} word - The word to select a contradiction meaning for\r\n * @param {Array} options - The options for this word\r\n * @returns {Object} - The selected contradiction meaning\r\n */\nfunction selectContradictionMeaning(word, options) {\n  // Filter to meanings that have contradiction sentences\n  const validMeanings = word.meanings.filter(meaning => meaning.contradictionSentences && meaning.contradictionSentences.length > 0 && options.some(option => option.text === meaning.definition && option.isCorrect));\n\n  // If no valid meanings, fall back to any meaning with contradiction sentences\n  if (validMeanings.length === 0) {\n    const fallbackMeanings = word.meanings.filter(meaning => meaning.contradictionSentences && meaning.contradictionSentences.length > 0);\n    if (fallbackMeanings.length > 0) {\n      const randomIndex = Math.floor(Math.random() * fallbackMeanings.length);\n      return fallbackMeanings[randomIndex];\n    }\n\n    // Last resort: just use the first meaning\n    return word.meanings[0];\n  }\n\n  // Select a random meaning from valid options\n  const randomIndex = Math.floor(Math.random() * validMeanings.length);\n  return validMeanings[randomIndex];\n}\n\n/**\r\n * Calculates the base score for a selection\r\n * @param {boolean} isCorrect - Whether the selection was correct\r\n * @returns {number} - The base score\r\n */\nfunction calculateBaseScore(isCorrect) {\n  return isCorrect ? 100 : 25;\n}\n\n/**\r\n * Calculates the time bonus for a round\r\n * @param {number} timeSpent - The time spent on the round\r\n * @param {number} timeLimit - The time limit for the round\r\n * @returns {number} - The time bonus multiplier\r\n */\nfunction calculateTimeBonus(timeSpent, timeLimit) {\n  if (timeLimit === 0) {\n    return 1.0; // No time bonus if no time limit\n  }\n\n  // Calculate bonus factor (1.0 to 1.5)\n  const timeRatio = 1 - timeSpent / timeLimit;\n  const bonus = 1.0 + timeRatio * 0.5;\n\n  // Ensure bonus is within bounds\n  return Math.max(1.0, Math.min(1.5, bonus));\n}\n\n/**\r\n * Gets the difficulty multiplier for scoring\r\n * @param {string} difficulty - The difficulty level\r\n * @returns {number} - The difficulty multiplier\r\n */\nfunction getDifficultyMultiplier(difficulty) {\n  switch (difficulty) {\n    case 'easy':\n      return 1.0;\n    case 'medium':\n      return 1.25;\n    case 'hard':\n      return 1.5;\n    default:\n      return 1.0;\n  }\n}\n\n/**\r\n * Generates performance feedback based on accuracy rate\r\n * @param {number} accuracyRate - The accuracy rate\r\n * @returns {string} - The performance feedback\r\n */\nfunction generatePerformanceFeedback(accuracyRate) {\n  if (accuracyRate >= 90) {\n    return \"Excellent! You have a strong understanding of how context affects meaning.\";\n  } else if (accuracyRate >= 70) {\n    return \"Good job! You're developing a solid grasp of contextual meaning.\";\n  } else if (accuracyRate >= 50) {\n    return \"Nice effort! This game highlights how tricky language can be without context.\";\n  } else {\n    return \"Great start! This game demonstrates why context is so crucial for understanding language.\";\n  }\n}\n\n/**\r\n * Suggests the next difficulty level based on performance\r\n * @param {Object} gameSession - The completed game session\r\n * @param {number} accuracyRate - The accuracy rate\r\n * @returns {string} - The suggestion\r\n */\nfunction suggestNextDifficulty(gameSession, accuracyRate) {\n  const currentDifficulty = gameSession.settings.difficulty;\n  if (currentDifficulty === 'easy' && accuracyRate >= 80) {\n    return \"You did great! Try Medium difficulty next for more challenging words.\";\n  } else if (currentDifficulty === 'medium' && accuracyRate >= 80) {\n    return \"Excellent work! Challenge yourself with Hard difficulty next time.\";\n  } else if (currentDifficulty === 'hard' && accuracyRate >= 70) {\n    return \"Outstanding! You've mastered even the most challenging words.\";\n  } else if (accuracyRate < 40) {\n    return \"Language is tricky! Try an easier difficulty to build your confidence.\";\n  } else {\n    return \"Play again to discover more words and their contextual meanings!\";\n  }\n}\n\n/**\r\n * Shuffles an array using the Fisher-Yates algorithm\r\n * @param {Array} array - The array to shuffle\r\n * @returns {Array} - The shuffled array\r\n */\nfunction shuffleArray(array) {\n  const result = [...array];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}","map":{"version":3,"names":["v4","uuidv4","selectWordsForGame","getDistractorsForWord","recordConceptExposure","initializeGame","settings","selectedWords","difficulty","roundCount","gameSession","id","startTime","Date","endTime","currentRound","totalRounds","score","rounds","completed","encounteredConcepts","Promise","all","map","word","index","options","generateMeaningOptions","correctMeaning","selectContradictionMeaning","markedOptions","option","isContradiction","text","definition","roundNumber","selectedOption","timeSpent","error","console","Error","startNextRound","getCurrentRound","processUserSelection","optionIndex","baseScore","calculateBaseScore","isCorrect","timeBonus","calculateTimeBonus","timeLimit","difficultyMultiplier","getDifficultyMultiplier","Math","round","categories","length","conceptId","getContradictionSentence","contradictionMeaning","sentences","contradictionSentences","randomIndex","floor","random","selectedSentence","regex","RegExp","highlightedSentence","replace","sentence","meaning","explanation","completeGame","totalTimeSpent","correctAnswers","forEach","averageTimePerRound","accuracyRate","performance","generatePerformanceFeedback","suggestion","suggestNextDifficulty","actualMeanings","meanings","slice","min","neededDistractors","distractors","distractor","_index","push","shuffleArray","validMeanings","filter","some","fallbackMeanings","timeRatio","bonus","max","currentDifficulty","array","result","i","j"],"sources":["C:/Users/abhay/Downloads/WordsEmptyMeaning/src/services/gameService.js"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\r\nimport { selectWordsForGame, getDistractorsForWord } from './wordService';\r\nimport { recordConceptExposure } from './educationalService';\r\n\r\n/**\r\n * Initializes a new game session\r\n * @param {Object} settings - Game settings (difficulty, roundCount, timeLimit, soundEnabled)\r\n * @returns {Promise<Object>} - A promise that resolves to a new game session\r\n */\r\nexport const initializeGame = async (settings) => {\r\n  try {\r\n    // Get words for the game based on difficulty and round count\r\n    const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\r\n    \r\n    // Create game session\r\n    const gameSession = {\r\n      id: uuidv4(),\r\n      startTime: new Date(),\r\n      endTime: null,\r\n      settings,\r\n      currentRound: 0,\r\n      totalRounds: settings.roundCount,\r\n      score: 0,\r\n      rounds: [],\r\n      completed: false,\r\n      encounteredConcepts: [],\r\n    };\r\n    \r\n    // Create rounds for each selected word\r\n    const rounds = await Promise.all(selectedWords.map(async (word, index) => {\r\n      // Generate options for this word\r\n      const options = await generateMeaningOptions(word);\r\n      \r\n      // Select a contradiction meaning\r\n      const correctMeaning = selectContradictionMeaning(word, options);\r\n      \r\n      // Mark the contradiction meaning in the options\r\n      const markedOptions = options.map(option => ({\r\n        ...option,\r\n        isContradiction: option.text === correctMeaning.definition\r\n      }));\r\n      \r\n      return {\r\n        roundNumber: index + 1,\r\n        word,\r\n        correctMeaning,\r\n        options: markedOptions,\r\n        selectedOption: null,\r\n        timeSpent: 0,\r\n        score: 0,\r\n        completed: false,\r\n      };\r\n    }));\r\n    \r\n    // Add rounds to game session\r\n    gameSession.rounds = rounds;\r\n    \r\n    return gameSession;\r\n  } catch (error) {\r\n    console.error('Error initializing game:', error);\r\n    throw new Error('Failed to initialize game');\r\n  }\r\n};\r\n\r\n/**\r\n * Starts the next round in a game session\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<boolean>} - A promise that resolves to true if successful, false if no more rounds\r\n */\r\nexport const startNextRound = async (gameSession) => {\r\n  try {\r\n    if (!gameSession) {\r\n      throw new Error('No active game session');\r\n    }\r\n    \r\n    if (gameSession.currentRound >= gameSession.totalRounds) {\r\n      return false; // No more rounds\r\n    }\r\n    \r\n    gameSession.currentRound += 1;\r\n    const currentRound = gameSession.rounds[gameSession.currentRound - 1];\r\n    \r\n    // Reset round state for new round\r\n    if (currentRound) {\r\n      currentRound.selectedOption = null;\r\n      currentRound.timeSpent = 0;\r\n      currentRound.score = 0;\r\n      currentRound.completed = false;\r\n    }\r\n    \r\n    return true; // Successfully started next round\r\n  } catch (error) {\r\n    console.error('Error starting next round:', error);\r\n    throw new Error('Failed to start next round');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets the current round from a game session\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Object|null} - The current round or null if no active round\r\n */\r\nexport const getCurrentRound = (gameSession) => {\r\n  if (!gameSession || gameSession.currentRound === 0 || gameSession.currentRound > gameSession.totalRounds) {\r\n    return null;\r\n  }\r\n  \r\n  return gameSession.rounds[gameSession.currentRound - 1];\r\n};\r\n\r\n/**\r\n * Processes a user's selection in the current round\r\n * @param {Object} gameSession - The current game session\r\n * @param {number} optionIndex - The index of the selected option\r\n * @param {number} timeSpent - The time spent on this round\r\n * @returns {Promise<Object>} - A promise that resolves to the updated round\r\n */\r\nexport const processUserSelection = async (gameSession, optionIndex, timeSpent) => {\r\n  try {\r\n    if (!gameSession) {\r\n      throw new Error('No active game session');\r\n    }\r\n    \r\n    const currentRound = getCurrentRound(gameSession);\r\n    \r\n    if (!currentRound) {\r\n      throw new Error('No active round');\r\n    }\r\n    \r\n    if (currentRound.completed) {\r\n      throw new Error('Round already completed');\r\n    }\r\n    \r\n    // Record user's selection\r\n    currentRound.selectedOption = optionIndex;\r\n    currentRound.timeSpent = timeSpent;\r\n    \r\n    const selectedOption = currentRound.options[optionIndex];\r\n    \r\n    if (!selectedOption) {\r\n      throw new Error('Invalid option selected');\r\n    }\r\n    \r\n    // Calculate score\r\n    const baseScore = calculateBaseScore(selectedOption.isCorrect);\r\n    const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\r\n    const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\r\n    \r\n    const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\r\n    currentRound.score = score;\r\n    \r\n    // Update total score\r\n    gameSession.score += score;\r\n    \r\n    // Mark round as completed\r\n    currentRound.completed = true;\r\n    \r\n    // Record concept exposure\r\n    if (currentRound.word.categories.length > 0) {\r\n      // Use the first category as a concept for now\r\n      // In a real implementation, this would be more sophisticated\r\n      const conceptId = currentRound.word.categories[0];\r\n      await recordConceptExposure(conceptId, gameSession);\r\n    }\r\n    \r\n    return currentRound;\r\n  } catch (error) {\r\n    console.error('Error processing user selection:', error);\r\n    throw new Error('Failed to process user selection');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets a contradiction sentence for the current round\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<Object>} - A promise that resolves to contradiction data\r\n */\r\nexport const getContradictionSentence = async (gameSession) => {\r\n  try {\r\n    const currentRound = getCurrentRound(gameSession);\r\n    \r\n    if (!currentRound || !currentRound.completed) {\r\n      throw new Error('No completed round to get contradiction for');\r\n    }\r\n    \r\n    // Get the contradiction meaning\r\n    const contradictionMeaning = currentRound.correctMeaning;\r\n    \r\n    // Get a random contradiction sentence\r\n    const sentences = contradictionMeaning.contradictionSentences;\r\n    const randomIndex = Math.floor(Math.random() * sentences.length);\r\n    const selectedSentence = sentences[randomIndex];\r\n    \r\n    // Create highlighted sentence by wrapping the word in a span\r\n    const word = currentRound.word.text;\r\n    const regex = new RegExp(`\\\\b${word}\\\\b`, 'i');\r\n    const highlightedSentence = selectedSentence.replace(regex, `<span class=\"highlight\">${word}</span>`);\r\n    \r\n    return {\r\n      sentence: selectedSentence,\r\n      highlightedSentence,\r\n      meaning: contradictionMeaning.definition,\r\n      explanation: `In this context, \"${word}\" means \"${contradictionMeaning.definition}\" rather than the meaning you selected.`\r\n    };\r\n  } catch (error) {\r\n    console.error('Error getting contradiction sentence:', error);\r\n    throw new Error('Failed to get contradiction sentence');\r\n  }\r\n};\r\n\r\n/**\r\n * Completes a game session and calculates final results\r\n * @param {Object} gameSession - The current game session\r\n * @returns {Promise<Object>} - A promise that resolves to the game results\r\n */\r\nexport const completeGame = async (gameSession) => {\r\n  try {\r\n    if (!gameSession) {\r\n      throw new Error('No active game session');\r\n    }\r\n    \r\n    if (gameSession.completed) {\r\n      throw new Error('Game already completed');\r\n    }\r\n    \r\n    // Set end time and mark as completed\r\n    gameSession.endTime = new Date();\r\n    gameSession.completed = true;\r\n    \r\n    // Calculate final statistics\r\n    let totalTimeSpent = 0;\r\n    let correctAnswers = 0;\r\n    \r\n    gameSession.rounds.forEach(round => {\r\n      totalTimeSpent += round.timeSpent;\r\n      \r\n      if (round.selectedOption !== null) {\r\n        const selectedOption = round.options[round.selectedOption];\r\n        if (selectedOption && selectedOption.isCorrect) {\r\n          correctAnswers += 1;\r\n        }\r\n      }\r\n    });\r\n    \r\n    const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\r\n    const accuracyRate = (correctAnswers / gameSession.totalRounds) * 100;\r\n    \r\n    // Generate performance feedback\r\n    const performance = generatePerformanceFeedback(accuracyRate);\r\n    \r\n    // Generate next difficulty suggestion\r\n    const suggestion = suggestNextDifficulty(gameSession, accuracyRate);\r\n    \r\n    return {\r\n      score: gameSession.score,\r\n      totalRounds: gameSession.totalRounds,\r\n      correctAnswers,\r\n      accuracyRate,\r\n      averageTimePerRound,\r\n      difficulty: gameSession.settings.difficulty,\r\n      performance,\r\n      suggestion,\r\n    };\r\n  } catch (error) {\r\n    console.error('Error completing game:', error);\r\n    throw new Error('Failed to complete game');\r\n  }\r\n};\r\n\r\n/**\r\n * Generates meaning options for a word\r\n * @param {Object} word - The word to generate options for\r\n * @returns {Promise<Array>} - A promise that resolves to an array of options\r\n */\r\nasync function generateMeaningOptions(word) {\r\n  try {\r\n    // Include actual meanings (up to 3)\r\n    const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\r\n    \r\n    const options = actualMeanings.map((meaning, index) => ({\r\n      index,\r\n      text: meaning.definition,\r\n      isCorrect: true,\r\n      isContradiction: false,\r\n    }));\r\n    \r\n    // Fill remaining slots with distractors\r\n    const neededDistractors = 4 - options.length;\r\n    \r\n    if (neededDistractors > 0) {\r\n      const distractors = await getDistractorsForWord(word, neededDistractors);\r\n      \r\n      distractors.forEach((distractor, _index) => {\r\n        options.push({\r\n          index: options.length,\r\n          text: distractor.definition,\r\n          isCorrect: false,\r\n          isContradiction: false,\r\n        });\r\n      });\r\n    }\r\n    \r\n    // Shuffle options\r\n    return shuffleArray(options);\r\n  } catch (error) {\r\n    console.error('Error generating meaning options:', error);\r\n    throw new Error('Failed to generate meaning options');\r\n  }\r\n}\r\n\r\n/**\r\n * Selects a contradiction meaning for a word\r\n * @param {Object} word - The word to select a contradiction meaning for\r\n * @param {Array} options - The options for this word\r\n * @returns {Object} - The selected contradiction meaning\r\n */\r\nfunction selectContradictionMeaning(word, options) {\r\n  // Filter to meanings that have contradiction sentences\r\n  const validMeanings = word.meanings.filter(meaning => \r\n    meaning.contradictionSentences && meaning.contradictionSentences.length > 0 &&\r\n    options.some(option => option.text === meaning.definition && option.isCorrect)\r\n  );\r\n  \r\n  // If no valid meanings, fall back to any meaning with contradiction sentences\r\n  if (validMeanings.length === 0) {\r\n    const fallbackMeanings = word.meanings.filter(meaning => \r\n      meaning.contradictionSentences && meaning.contradictionSentences.length > 0\r\n    );\r\n    \r\n    if (fallbackMeanings.length > 0) {\r\n      const randomIndex = Math.floor(Math.random() * fallbackMeanings.length);\r\n      return fallbackMeanings[randomIndex];\r\n    }\r\n    \r\n    // Last resort: just use the first meaning\r\n    return word.meanings[0];\r\n  }\r\n  \r\n  // Select a random meaning from valid options\r\n  const randomIndex = Math.floor(Math.random() * validMeanings.length);\r\n  return validMeanings[randomIndex];\r\n}\r\n\r\n/**\r\n * Calculates the base score for a selection\r\n * @param {boolean} isCorrect - Whether the selection was correct\r\n * @returns {number} - The base score\r\n */\r\nfunction calculateBaseScore(isCorrect) {\r\n  return isCorrect ? 100 : 25;\r\n}\r\n\r\n/**\r\n * Calculates the time bonus for a round\r\n * @param {number} timeSpent - The time spent on the round\r\n * @param {number} timeLimit - The time limit for the round\r\n * @returns {number} - The time bonus multiplier\r\n */\r\nfunction calculateTimeBonus(timeSpent, timeLimit) {\r\n  if (timeLimit === 0) {\r\n    return 1.0; // No time bonus if no time limit\r\n  }\r\n  \r\n  // Calculate bonus factor (1.0 to 1.5)\r\n  const timeRatio = 1 - (timeSpent / timeLimit);\r\n  const bonus = 1.0 + (timeRatio * 0.5);\r\n  \r\n  // Ensure bonus is within bounds\r\n  return Math.max(1.0, Math.min(1.5, bonus));\r\n}\r\n\r\n/**\r\n * Gets the difficulty multiplier for scoring\r\n * @param {string} difficulty - The difficulty level\r\n * @returns {number} - The difficulty multiplier\r\n */\r\nfunction getDifficultyMultiplier(difficulty) {\r\n  switch (difficulty) {\r\n    case 'easy':\r\n      return 1.0;\r\n    case 'medium':\r\n      return 1.25;\r\n    case 'hard':\r\n      return 1.5;\r\n    default:\r\n      return 1.0;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates performance feedback based on accuracy rate\r\n * @param {number} accuracyRate - The accuracy rate\r\n * @returns {string} - The performance feedback\r\n */\r\nfunction generatePerformanceFeedback(accuracyRate) {\r\n  if (accuracyRate >= 90) {\r\n    return \"Excellent! You have a strong understanding of how context affects meaning.\";\r\n  } else if (accuracyRate >= 70) {\r\n    return \"Good job! You're developing a solid grasp of contextual meaning.\";\r\n  } else if (accuracyRate >= 50) {\r\n    return \"Nice effort! This game highlights how tricky language can be without context.\";\r\n  } else {\r\n    return \"Great start! This game demonstrates why context is so crucial for understanding language.\";\r\n  }\r\n}\r\n\r\n/**\r\n * Suggests the next difficulty level based on performance\r\n * @param {Object} gameSession - The completed game session\r\n * @param {number} accuracyRate - The accuracy rate\r\n * @returns {string} - The suggestion\r\n */\r\nfunction suggestNextDifficulty(gameSession, accuracyRate) {\r\n  const currentDifficulty = gameSession.settings.difficulty;\r\n  \r\n  if (currentDifficulty === 'easy' && accuracyRate >= 80) {\r\n    return \"You did great! Try Medium difficulty next for more challenging words.\";\r\n  } else if (currentDifficulty === 'medium' && accuracyRate >= 80) {\r\n    return \"Excellent work! Challenge yourself with Hard difficulty next time.\";\r\n  } else if (currentDifficulty === 'hard' && accuracyRate >= 70) {\r\n    return \"Outstanding! You've mastered even the most challenging words.\";\r\n  } else if (accuracyRate < 40) {\r\n    return \"Language is tricky! Try an easier difficulty to build your confidence.\";\r\n  } else {\r\n    return \"Play again to discover more words and their contextual meanings!\";\r\n  }\r\n}\r\n\r\n/**\r\n * Shuffles an array using the Fisher-Yates algorithm\r\n * @param {Array} array - The array to shuffle\r\n * @returns {Array} - The shuffled array\r\n */\r\nfunction shuffleArray(array) {\r\n  const result = [...array];\r\n  \r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  \r\n  return result;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}