{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { v4 as uuidv4 } from 'uuid';\nimport { selectWordsForGame } from '../../services/wordService';\n\n// Initial state\nconst initialState = {\n  gameSession: null,\n  loading: false,\n  error: null\n};\n\n// Async thunks\nexport const initializeGame = createAsyncThunk('game/initializeGame', async (settings, {\n  rejectWithValue\n}) => {\n  try {\n    // Get words for the game based on difficulty and round count\n    const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\n\n    // Create game session\n    const gameSession = {\n      id: uuidv4(),\n      startTime: new Date(),\n      endTime: null,\n      settings,\n      currentRound: 0,\n      totalRounds: settings.roundCount,\n      score: 0,\n      rounds: [],\n      completed: false,\n      encounteredConcepts: []\n    };\n\n    // Create rounds for each selected word\n    const rounds = selectedWords.map((word, index) => {\n      // Generate options for this word\n      const options = generateMeaningOptions(word);\n\n      // Select a contradiction meaning\n      const correctMeaning = selectContradictionMeaning(word, options);\n\n      // Mark the contradiction meaning in the options\n      const markedOptions = options.map(option => ({\n        ...option,\n        isContradiction: option.text === correctMeaning.definition\n      }));\n      return {\n        roundNumber: index + 1,\n        word,\n        correctMeaning,\n        options: markedOptions,\n        selectedOption: null,\n        timeSpent: 0,\n        score: 0,\n        completed: false\n      };\n    });\n\n    // Add rounds to game session\n    gameSession.rounds = rounds;\n    return gameSession;\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\nexport const startNextRound = createAsyncThunk('game/startNextRound', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      console.error(\"No active game session\");\n      throw new Error('No active game session');\n    }\n    if (gameSession.currentRound >= gameSession.totalRounds) {\n      console.error(\"No more rounds available\");\n      throw new Error('No more rounds available');\n    }\n    const nextRound = gameSession.currentRound + 1;\n    return nextRound;\n  } catch (error) {\n    console.error(\"Error in startNextRound:\", error);\n    return rejectWithValue(error.message);\n  }\n});\nexport const processUserSelection = createAsyncThunk('game/processUserSelection', async ({\n  optionIndex,\n  timeSpent\n}, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      console.error(\"No active game session\");\n      throw new Error('No active game session');\n    }\n    const currentRound = gameSession.rounds[gameSession.currentRound - 1];\n    if (!currentRound) {\n      console.error(\"Invalid round\");\n      throw new Error('Invalid round');\n    }\n    const selectedOption = currentRound.options[optionIndex];\n    if (!selectedOption) {\n      console.error(\"Invalid option selected\");\n      throw new Error('Invalid option selected');\n    }\n\n    // Calculate score\n    const baseScore = selectedOption.isCorrect ? 100 : 25;\n    const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\n    const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\n    const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\n    return {\n      roundIndex: gameSession.currentRound - 1,\n      optionIndex,\n      timeSpent,\n      score\n    };\n  } catch (error) {\n    console.error(\"Error in processUserSelection:\", error);\n    return rejectWithValue(error.message);\n  }\n});\nexport const completeGame = createAsyncThunk('game/completeGame', async (_, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    const {\n      game\n    } = getState();\n    const {\n      gameSession\n    } = game;\n    if (!gameSession) {\n      throw new Error('No active game session');\n    }\n\n    // Calculate final statistics\n    let totalTimeSpent = 0;\n    let correctAnswers = 0;\n    gameSession.rounds.forEach(round => {\n      totalTimeSpent += round.timeSpent;\n      if (round.selectedOption !== null) {\n        const selectedOption = round.options[round.selectedOption];\n        if (selectedOption && selectedOption.isCorrect) {\n          correctAnswers += 1;\n        }\n      }\n    });\n    const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\n    const accuracyRate = correctAnswers / gameSession.totalRounds * 100;\n    return {\n      endTime: new Date(),\n      totalTimeSpent,\n      correctAnswers,\n      averageTimePerRound,\n      accuracyRate\n    };\n  } catch (error) {\n    return rejectWithValue(error.message);\n  }\n});\n\n// Helper functions\nfunction generateMeaningOptions(word) {\n  // In a real implementation, this would generate options based on the word's meanings\n  // and distractors from the database. For now, we'll create a simplified version.\n\n  // Include actual meanings (up to 3)\n  const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\n  const options = actualMeanings.map((meaning, index) => ({\n    index,\n    text: meaning.definition,\n    isCorrect: true,\n    isContradiction: false\n  }));\n\n  // Fill remaining slots with distractors\n  const neededDistractors = 4 - options.length;\n  if (neededDistractors > 0) {\n    // In a real implementation, these would come from a distractor database\n    const dummyDistractors = [\"To prepare food by heating it in an oven\", \"A small, round fruit with red or green skin\", \"A device used for measuring time\", \"A large, four-legged animal with a trunk\"].slice(0, neededDistractors);\n    dummyDistractors.forEach((distractor, _index) => {\n      options.push({\n        index: options.length,\n        text: distractor,\n        isCorrect: false,\n        isContradiction: false\n      });\n    });\n  }\n\n  // Shuffle options\n  return shuffleArray(options);\n}\nfunction selectContradictionMeaning(word, options) {\n  // In a real implementation, this would select a meaning that has contradiction sentences\n  // For now, we'll just pick one of the correct meanings\n\n  const correctOptions = options.filter(option => option.isCorrect);\n  if (correctOptions.length === 0) {\n    // Fallback to any meaning if no correct options\n    return word.meanings[0];\n  }\n  const randomIndex = Math.floor(Math.random() * correctOptions.length);\n  const selectedOption = correctOptions[randomIndex];\n\n  // Find the corresponding meaning\n  return word.meanings.find(meaning => meaning.definition === selectedOption.text) || word.meanings[0];\n}\nfunction calculateTimeBonus(timeSpent, timeLimit) {\n  if (timeLimit === 0) {\n    return 1.0; // No time bonus if no time limit\n  }\n\n  // Calculate bonus factor (1.0 to 1.5)\n  const timeRatio = 1 - timeSpent / timeLimit;\n  const bonus = 1.0 + timeRatio * 0.5;\n\n  // Ensure bonus is within bounds\n  return Math.max(1.0, Math.min(1.5, bonus));\n}\nfunction getDifficultyMultiplier(difficulty) {\n  switch (difficulty) {\n    case 'easy':\n      return 1.0;\n    case 'medium':\n      return 1.25;\n    case 'hard':\n      return 1.5;\n    default:\n      return 1.0;\n  }\n}\nfunction shuffleArray(array) {\n  const result = [...array];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}\n\n// Create slice\nconst gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    resetGame: state => {\n      state.gameSession = null;\n      state.loading = false;\n      state.error = null;\n    },\n    restoreSession: (state, action) => {\n      // When restoring a session, ensure the local state is properly initialized\n      const session = action.payload;\n\n      // If the session has a current round, ensure it's not marked as completed\n      // unless the game itself is completed\n      if (session && !session.completed && session.currentRound > 0 && session.rounds) {\n        const currentRoundIndex = session.currentRound - 1;\n        if (currentRoundIndex >= 0 && currentRoundIndex < session.rounds.length) {\n          // Reset the current round's state to ensure options aren't disabled\n          session.rounds[currentRoundIndex].selectedOption = null;\n          session.rounds[currentRoundIndex].completed = false;\n        }\n      }\n      state.gameSession = session;\n      state.loading = false;\n      state.error = null;\n    },\n    clearRoundSelection: state => {\n      // Clear the selection for the current round\n      if (state.gameSession && state.gameSession.currentRound > 0) {\n        const currentRoundIndex = state.gameSession.currentRound - 1;\n        if (currentRoundIndex >= 0 && currentRoundIndex < state.gameSession.rounds.length) {\n          state.gameSession.rounds[currentRoundIndex].selectedOption = null;\n        }\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Initialize game\n    .addCase(initializeGame.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(initializeGame.fulfilled, (state, action) => {\n      state.gameSession = action.payload;\n      state.loading = false;\n    }).addCase(initializeGame.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Start next round\n    .addCase(startNextRound.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(startNextRound.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        state.gameSession.currentRound = action.payload;\n      } else {\n        console.error(\"Cannot update currentRound: gameSession is null\");\n      }\n      state.loading = false;\n    }).addCase(startNextRound.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Process user selection\n    .addCase(processUserSelection.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(processUserSelection.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        const {\n          roundIndex,\n          optionIndex,\n          timeSpent,\n          score\n        } = action.payload;\n        const round = state.gameSession.rounds[roundIndex];\n        if (round) {\n          round.selectedOption = optionIndex;\n          round.timeSpent = timeSpent;\n          round.score = score;\n          round.completed = true;\n\n          // Update total score\n          state.gameSession.score += score;\n        } else {\n          console.error(\"Cannot update round: round is null\");\n        }\n      } else {\n        console.error(\"Cannot update round: gameSession is null\");\n      }\n      state.loading = false;\n    }).addCase(processUserSelection.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    })\n\n    // Complete game\n    .addCase(completeGame.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(completeGame.fulfilled, (state, action) => {\n      if (state.gameSession) {\n        state.gameSession.endTime = action.payload.endTime;\n        state.gameSession.completed = true;\n      }\n      state.loading = false;\n    }).addCase(completeGame.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.payload;\n    });\n  }\n});\n\n// Export actions and reducer\nexport const {\n  resetGame,\n  restoreSession,\n  clearRoundSelection\n} = gameSlice.actions;\nexport default gameSlice.reducer;\n\n// Selectors\nexport const selectGameSession = state => state.game.gameSession;\nexport const selectCurrentRound = state => {\n  const {\n    gameSession\n  } = state.game;\n  if (!gameSession || gameSession.currentRound === 0) {\n    return null;\n  }\n  return gameSession.rounds[gameSession.currentRound - 1];\n};\nexport const selectGameLoading = state => state.game.loading;\nexport const selectGameError = state => state.game.error;","map":{"version":3,"names":["createSlice","createAsyncThunk","v4","uuidv4","selectWordsForGame","initialState","gameSession","loading","error","initializeGame","settings","rejectWithValue","selectedWords","difficulty","roundCount","id","startTime","Date","endTime","currentRound","totalRounds","score","rounds","completed","encounteredConcepts","map","word","index","options","generateMeaningOptions","correctMeaning","selectContradictionMeaning","markedOptions","option","isContradiction","text","definition","roundNumber","selectedOption","timeSpent","message","startNextRound","_","getState","game","console","Error","nextRound","processUserSelection","optionIndex","baseScore","isCorrect","timeBonus","calculateTimeBonus","timeLimit","difficultyMultiplier","getDifficultyMultiplier","Math","round","roundIndex","completeGame","totalTimeSpent","correctAnswers","forEach","averageTimePerRound","accuracyRate","actualMeanings","meanings","slice","min","length","meaning","neededDistractors","dummyDistractors","distractor","_index","push","shuffleArray","correctOptions","filter","randomIndex","floor","random","find","timeRatio","bonus","max","array","result","i","j","gameSlice","name","reducers","resetGame","state","restoreSession","action","session","payload","currentRoundIndex","clearRoundSelection","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectGameSession","selectCurrentRound","selectGameLoading","selectGameError"],"sources":["C:/Users/abhay/Downloads/WordHaveNoMeaning/src/store/slices/gameSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { selectWordsForGame } from '../../services/wordService';\r\n\r\n// Initial state\r\nconst initialState = {\r\n  gameSession: null,\r\n  loading: false,\r\n  error: null,\r\n};\r\n\r\n// Async thunks\r\nexport const initializeGame = createAsyncThunk(\r\n  'game/initializeGame',\r\n  async (settings, { rejectWithValue }) => {\r\n    try {\r\n      // Get words for the game based on difficulty and round count\r\n      const selectedWords = await selectWordsForGame(settings.difficulty, settings.roundCount);\r\n      \r\n      // Create game session\r\n      const gameSession = {\r\n        id: uuidv4(),\r\n        startTime: new Date(),\r\n        endTime: null,\r\n        settings,\r\n        currentRound: 0,\r\n        totalRounds: settings.roundCount,\r\n        score: 0,\r\n        rounds: [],\r\n        completed: false,\r\n        encounteredConcepts: [],\r\n      };\r\n      \r\n      // Create rounds for each selected word\r\n      const rounds = selectedWords.map((word, index) => {\r\n        // Generate options for this word\r\n        const options = generateMeaningOptions(word);\r\n        \r\n        // Select a contradiction meaning\r\n        const correctMeaning = selectContradictionMeaning(word, options);\r\n        \r\n        // Mark the contradiction meaning in the options\r\n        const markedOptions = options.map(option => ({\r\n          ...option,\r\n          isContradiction: option.text === correctMeaning.definition\r\n        }));\r\n        \r\n        return {\r\n          roundNumber: index + 1,\r\n          word,\r\n          correctMeaning,\r\n          options: markedOptions,\r\n          selectedOption: null,\r\n          timeSpent: 0,\r\n          score: 0,\r\n          completed: false,\r\n        };\r\n      });\r\n      \r\n      // Add rounds to game session\r\n      gameSession.rounds = rounds;\r\n      \r\n      return gameSession;\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const startNextRound = createAsyncThunk(\r\n  'game/startNextRound',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n    \r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      \r\n      \r\n      if (!gameSession) {\r\n        console.error(\"No active game session\");\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      if (gameSession.currentRound >= gameSession.totalRounds) {\r\n        console.error(\"No more rounds available\");\r\n        throw new Error('No more rounds available');\r\n      }\r\n      \r\n      const nextRound = gameSession.currentRound + 1;\r\n      \r\n      return nextRound;\r\n    } catch (error) {\r\n      console.error(\"Error in startNextRound:\", error);\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const processUserSelection = createAsyncThunk(\r\n  'game/processUserSelection',\r\n  async ({ optionIndex, timeSpent }, { getState, rejectWithValue }) => {\r\n    try {\r\n\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n  \r\n      \r\n      if (!gameSession) {\r\n        console.error(\"No active game session\");\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      const currentRound = gameSession.rounds[gameSession.currentRound - 1];\r\n      \r\n      if (!currentRound) {\r\n        console.error(\"Invalid round\");\r\n        throw new Error('Invalid round');\r\n      }\r\n      \r\n  \r\n      \r\n      const selectedOption = currentRound.options[optionIndex];\r\n      \r\n      if (!selectedOption) {\r\n        console.error(\"Invalid option selected\");\r\n        throw new Error('Invalid option selected');\r\n      }\r\n      \r\n     \r\n      \r\n      // Calculate score\r\n      const baseScore = selectedOption.isCorrect ? 100 : 25;\r\n      const timeBonus = calculateTimeBonus(timeSpent, gameSession.settings.timeLimit);\r\n      const difficultyMultiplier = getDifficultyMultiplier(gameSession.settings.difficulty);\r\n      \r\n      const score = Math.round(baseScore * timeBonus * difficultyMultiplier);\r\n     \r\n      \r\n      return {\r\n        roundIndex: gameSession.currentRound - 1,\r\n        optionIndex,\r\n        timeSpent,\r\n        score,\r\n      };\r\n    } catch (error) {\r\n      console.error(\"Error in processUserSelection:\", error);\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\nexport const completeGame = createAsyncThunk(\r\n  'game/completeGame',\r\n  async (_, { getState, rejectWithValue }) => {\r\n    try {\r\n      const { game } = getState();\r\n      const { gameSession } = game;\r\n      \r\n      if (!gameSession) {\r\n        throw new Error('No active game session');\r\n      }\r\n      \r\n      // Calculate final statistics\r\n      let totalTimeSpent = 0;\r\n      let correctAnswers = 0;\r\n      \r\n      gameSession.rounds.forEach(round => {\r\n        totalTimeSpent += round.timeSpent;\r\n        \r\n        if (round.selectedOption !== null) {\r\n          const selectedOption = round.options[round.selectedOption];\r\n          if (selectedOption && selectedOption.isCorrect) {\r\n            correctAnswers += 1;\r\n          }\r\n        }\r\n      });\r\n      \r\n      const averageTimePerRound = totalTimeSpent / gameSession.totalRounds;\r\n      const accuracyRate = (correctAnswers / gameSession.totalRounds) * 100;\r\n      \r\n      return {\r\n        endTime: new Date(),\r\n        totalTimeSpent,\r\n        correctAnswers,\r\n        averageTimePerRound,\r\n        accuracyRate,\r\n      };\r\n    } catch (error) {\r\n      return rejectWithValue(error.message);\r\n    }\r\n  }\r\n);\r\n\r\n// Helper functions\r\nfunction generateMeaningOptions(word) {\r\n  // In a real implementation, this would generate options based on the word's meanings\r\n  // and distractors from the database. For now, we'll create a simplified version.\r\n  \r\n  // Include actual meanings (up to 3)\r\n  const actualMeanings = word.meanings.slice(0, Math.min(3, word.meanings.length));\r\n  \r\n  const options = actualMeanings.map((meaning, index) => ({\r\n    index,\r\n    text: meaning.definition,\r\n    isCorrect: true,\r\n    isContradiction: false,\r\n  }));\r\n  \r\n  // Fill remaining slots with distractors\r\n  const neededDistractors = 4 - options.length;\r\n  \r\n  if (neededDistractors > 0) {\r\n    // In a real implementation, these would come from a distractor database\r\n    const dummyDistractors = [\r\n      \"To prepare food by heating it in an oven\",\r\n      \"A small, round fruit with red or green skin\",\r\n      \"A device used for measuring time\",\r\n      \"A large, four-legged animal with a trunk\",\r\n    ].slice(0, neededDistractors);\r\n    \r\n    dummyDistractors.forEach((distractor, _index) => {\r\n      options.push({\r\n        index: options.length,\r\n        text: distractor,\r\n        isCorrect: false,\r\n        isContradiction: false,\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Shuffle options\r\n  return shuffleArray(options);\r\n}\r\n\r\nfunction selectContradictionMeaning(word, options) {\r\n  // In a real implementation, this would select a meaning that has contradiction sentences\r\n  // For now, we'll just pick one of the correct meanings\r\n  \r\n  const correctOptions = options.filter(option => option.isCorrect);\r\n  \r\n  if (correctOptions.length === 0) {\r\n    // Fallback to any meaning if no correct options\r\n    return word.meanings[0];\r\n  }\r\n  \r\n  const randomIndex = Math.floor(Math.random() * correctOptions.length);\r\n  const selectedOption = correctOptions[randomIndex];\r\n  \r\n  // Find the corresponding meaning\r\n  return word.meanings.find(meaning => meaning.definition === selectedOption.text) || word.meanings[0];\r\n}\r\n\r\nfunction calculateTimeBonus(timeSpent, timeLimit) {\r\n  if (timeLimit === 0) {\r\n    return 1.0; // No time bonus if no time limit\r\n  }\r\n  \r\n  // Calculate bonus factor (1.0 to 1.5)\r\n  const timeRatio = 1 - (timeSpent / timeLimit);\r\n  const bonus = 1.0 + (timeRatio * 0.5);\r\n  \r\n  // Ensure bonus is within bounds\r\n  return Math.max(1.0, Math.min(1.5, bonus));\r\n}\r\n\r\nfunction getDifficultyMultiplier(difficulty) {\r\n  switch (difficulty) {\r\n    case 'easy':\r\n      return 1.0;\r\n    case 'medium':\r\n      return 1.25;\r\n    case 'hard':\r\n      return 1.5;\r\n    default:\r\n      return 1.0;\r\n  }\r\n}\r\n\r\nfunction shuffleArray(array) {\r\n  const result = [...array];\r\n  \r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n// Create slice\r\nconst gameSlice = createSlice({\r\n  name: 'game',\r\n  initialState,\r\n  reducers: {\r\n    resetGame: (state) => {\r\n      state.gameSession = null;\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n    restoreSession: (state, action) => {\r\n      // When restoring a session, ensure the local state is properly initialized\r\n      const session = action.payload;\r\n      \r\n      // If the session has a current round, ensure it's not marked as completed\r\n      // unless the game itself is completed\r\n      if (session && !session.completed && session.currentRound > 0 && session.rounds) {\r\n        const currentRoundIndex = session.currentRound - 1;\r\n        if (currentRoundIndex >= 0 && currentRoundIndex < session.rounds.length) {\r\n          // Reset the current round's state to ensure options aren't disabled\r\n          session.rounds[currentRoundIndex].selectedOption = null;\r\n          session.rounds[currentRoundIndex].completed = false;\r\n        }\r\n      }\r\n      \r\n      state.gameSession = session;\r\n      state.loading = false;\r\n      state.error = null;\r\n    },\r\n    clearRoundSelection: (state) => {\r\n      // Clear the selection for the current round\r\n      if (state.gameSession && state.gameSession.currentRound > 0) {\r\n        const currentRoundIndex = state.gameSession.currentRound - 1;\r\n        if (currentRoundIndex >= 0 && currentRoundIndex < state.gameSession.rounds.length) {\r\n          state.gameSession.rounds[currentRoundIndex].selectedOption = null;\r\n        }\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Initialize game\r\n      .addCase(initializeGame.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(initializeGame.fulfilled, (state, action) => {\r\n        state.gameSession = action.payload;\r\n        state.loading = false;\r\n      })\r\n      .addCase(initializeGame.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Start next round\r\n      .addCase(startNextRound.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(startNextRound.fulfilled, (state, action) => {\r\n       \r\n        if (state.gameSession) {\r\n          state.gameSession.currentRound = action.payload;\r\n        \r\n        } else {\r\n          console.error(\"Cannot update currentRound: gameSession is null\");\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(startNextRound.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Process user selection\r\n      .addCase(processUserSelection.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(processUserSelection.fulfilled, (state, action) => {\r\n     \r\n        if (state.gameSession) {\r\n          const { roundIndex, optionIndex, timeSpent, score } = action.payload;\r\n          const round = state.gameSession.rounds[roundIndex];\r\n          \r\n          if (round) {\r\n          \r\n            round.selectedOption = optionIndex;\r\n            round.timeSpent = timeSpent;\r\n            round.score = score;\r\n            round.completed = true;\r\n            \r\n            // Update total score\r\n            state.gameSession.score += score;\r\n            \r\n          } else {\r\n            console.error(\"Cannot update round: round is null\");\r\n          }\r\n        } else {\r\n          console.error(\"Cannot update round: gameSession is null\");\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(processUserSelection.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Complete game\r\n      .addCase(completeGame.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(completeGame.fulfilled, (state, action) => {\r\n        if (state.gameSession) {\r\n          state.gameSession.endTime = action.payload.endTime;\r\n          state.gameSession.completed = true;\r\n        }\r\n        state.loading = false;\r\n      })\r\n      .addCase(completeGame.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.payload;\r\n      });\r\n  },\r\n});\r\n\r\n// Export actions and reducer\r\nexport const { resetGame, restoreSession, clearRoundSelection } = gameSlice.actions;\r\nexport default gameSlice.reducer;\r\n\r\n// Selectors\r\nexport const selectGameSession = (state) => state.game.gameSession;\r\nexport const selectCurrentRound = (state) => {\r\n  const { gameSession } = state.game;\r\n  \r\n  if (!gameSession || gameSession.currentRound === 0) {\r\n    return null;\r\n  }\r\n  \r\n  return gameSession.rounds[gameSession.currentRound - 1];\r\n};\r\nexport const selectGameLoading = (state) => state.game.loading;\r\nexport const selectGameError = (state) => state.game.error;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}