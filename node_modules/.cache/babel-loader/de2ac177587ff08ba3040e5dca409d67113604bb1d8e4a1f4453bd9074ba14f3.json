{"ast":null,"code":"import { wordDatabase } from '../data/wordDatabase';\n\n// Keep track of recently used words to prevent repetition\nconst recentlyUsedWords = new Set();\nconst MAX_RECENT_WORDS = 50; // Maximum number of words to track\n\n/**\r\n * Selects words for a game based on difficulty and count\r\n * @param {string} difficulty - The difficulty level ('easy', 'medium', 'hard')\r\n * @param {number} count - The number of words to select\r\n * @returns {Promise<Array>} - A promise that resolves to an array of selected words\r\n */\nexport const selectWordsForGame = async (difficulty, count) => {\n  try {\n    // Get words of the requested difficulty\n    let availableWords = wordDatabase.filter(word => word.difficulty === difficulty);\n\n    // Filter out recently used words to prevent repetition\n    let filteredWords = availableWords.filter(word => !recentlyUsedWords.has(word.id));\n\n    // If not enough words after filtering, expand to adjacent difficulties\n    if (filteredWords.length < count) {\n      let additionalWords = [];\n      if (difficulty === 'easy') {\n        additionalWords = wordDatabase.filter(word => word.difficulty === 'medium' && !recentlyUsedWords.has(word.id));\n      } else if (difficulty === 'hard') {\n        additionalWords = wordDatabase.filter(word => word.difficulty === 'medium' && !recentlyUsedWords.has(word.id));\n      } else {\n        additionalWords = [...wordDatabase.filter(word => word.difficulty === 'easy' && !recentlyUsedWords.has(word.id)), ...wordDatabase.filter(word => word.difficulty === 'hard' && !recentlyUsedWords.has(word.id))];\n      }\n      filteredWords = [...filteredWords, ...additionalWords];\n    }\n\n    // If still not enough words, include some recently used words as a last resort\n    if (filteredWords.length < count) {\n      const remainingNeeded = count - filteredWords.length;\n      const recentlyUsedArray = Array.from(recentlyUsedWords).map(id => wordDatabase.find(word => word.id === id)).filter(word => word); // Filter out any undefined values\n\n      // Prioritize words of the requested difficulty\n      const prioritizedRecent = [...recentlyUsedArray.filter(word => word.difficulty === difficulty), ...recentlyUsedArray.filter(word => word.difficulty !== difficulty)];\n      filteredWords = [...filteredWords, ...prioritizedRecent.slice(0, remainingNeeded)];\n    }\n\n    // Shuffle and select required number of words\n    const shuffledWords = shuffleArray(filteredWords);\n    const selectedWords = shuffledWords.slice(0, count);\n\n    // Add selected words to recently used set\n    selectedWords.forEach(word => {\n      recentlyUsedWords.add(word.id);\n\n      // If the set gets too large, remove the oldest entries\n      if (recentlyUsedWords.size > MAX_RECENT_WORDS) {\n        const oldestWord = recentlyUsedWords.values().next().value;\n        recentlyUsedWords.delete(oldestWord);\n      }\n    });\n    return selectedWords;\n  } catch (error) {\n    console.error('Error selecting words:', error);\n    throw new Error('Failed to select words for the game');\n  }\n};\n\n/**\r\n * Gets a word by its ID\r\n * @param {string} wordId - The ID of the word to retrieve\r\n * @returns {Promise<Object>} - A promise that resolves to the word object\r\n */\nexport const getWordById = async wordId => {\n  try {\n    const word = wordDatabase.find(w => w.id === wordId);\n    if (!word) {\n      throw new Error(`Word with ID ${wordId} not found`);\n    }\n    return word;\n  } catch (error) {\n    console.error('Error getting word:', error);\n    throw new Error('Failed to get word');\n  }\n};\n\n/**\r\n * Gets words by difficulty level\r\n * @param {string} difficulty - The difficulty level ('easy', 'medium', 'hard')\r\n * @returns {Promise<Array>} - A promise that resolves to an array of words\r\n */\nexport const getWordsByDifficulty = async difficulty => {\n  try {\n    const words = wordDatabase.filter(word => word.difficulty === difficulty);\n    return words;\n  } catch (error) {\n    console.error('Error getting words by difficulty:', error);\n    throw new Error('Failed to get words by difficulty');\n  }\n};\n\n/**\r\n * Gets words by category\r\n * @param {string} category - The category to filter by\r\n * @returns {Promise<Array>} - A promise that resolves to an array of words\r\n */\nexport const getWordsByCategory = async category => {\n  try {\n    const words = wordDatabase.filter(word => word.categories.includes(category));\n    return words;\n  } catch (error) {\n    console.error('Error getting words by category:', error);\n    throw new Error('Failed to get words by category');\n  }\n};\n\n/**\r\n * Gets distractors for a word\r\n * @param {Object} word - The word to get distractors for\r\n * @param {number} count - The number of distractors to get\r\n * @returns {Promise<Array>} - A promise that resolves to an array of distractors\r\n */\nexport const getDistractorsForWord = async (word, count) => {\n  try {\n    // Enhanced distractor generation\n    // First, try to find semantically related but incorrect definitions from other words\n    const relatedDistractors = [];\n\n    // Look for words in the same categories but with different meanings\n    const relatedWords = wordDatabase.filter(w => w.id !== word.id &&\n    // Not the same word\n    w.categories.some(cat => word.categories.includes(cat)) // Has at least one matching category\n    );\n\n    // Extract meanings from related words\n    if (relatedWords.length > 0) {\n      relatedWords.forEach(relatedWord => {\n        relatedWord.meanings.forEach(meaning => {\n          // Check if this meaning is sufficiently different from our word's meanings\n          const isDifferentMeaning = word.meanings.every(m => !areSimilarDefinitions(m.definition, meaning.definition));\n          if (isDifferentMeaning) {\n            relatedDistractors.push({\n              id: `distractor_${relatedWord.id}_${meaning.id}`,\n              definition: meaning.definition,\n              forWordTypes: [meaning.partOfSpeech],\n              difficulty: word.difficulty,\n              source: 'related_word'\n            });\n          }\n        });\n      });\n    }\n\n    // Fallback distractors if we don't have enough related ones\n    const fallbackDistractors = [{\n      id: 'distractor_001',\n      definition: 'To prepare food by heating it in an oven',\n      forWordTypes: ['noun', 'verb'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_002',\n      definition: 'A small, round fruit with red or green skin',\n      forWordTypes: ['noun'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_003',\n      definition: 'A device used for measuring time',\n      forWordTypes: ['noun'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_004',\n      definition: 'A large, four-legged animal with a trunk',\n      forWordTypes: ['noun'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_005',\n      definition: 'To move quickly on foot',\n      forWordTypes: ['verb'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_006',\n      definition: 'A small, flying insect that produces honey',\n      forWordTypes: ['noun'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_007',\n      definition: 'A tall plant with a hard trunk and branches',\n      forWordTypes: ['noun'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }, {\n      id: 'distractor_008',\n      definition: 'To speak in a loud voice',\n      forWordTypes: ['verb'],\n      difficulty: word.difficulty,\n      source: 'fallback'\n    }];\n\n    // Combine related and fallback distractors\n    const allDistractors = [...relatedDistractors, ...fallbackDistractors];\n\n    // Filter distractors that are appropriate for this word's type\n    const filteredDistractors = allDistractors.filter(distractor => distractor.forWordTypes.some(type => word.categories.includes(type)));\n\n    // Prioritize related distractors over fallback ones\n    const prioritizedDistractors = [...filteredDistractors.filter(d => d.source === 'related_word'), ...filteredDistractors.filter(d => d.source === 'fallback')];\n\n    // Shuffle and select required number of distractors\n    const shuffledDistractors = shuffleArray(prioritizedDistractors);\n    const selectedDistractors = shuffledDistractors.slice(0, count);\n    return selectedDistractors;\n  } catch (error) {\n    console.error('Error getting distractors:', error);\n    throw new Error('Failed to get distractors for word');\n  }\n};\n\n/**\r\n * Checks if two definitions are similar\r\n * @param {string} def1 - First definition\r\n * @param {string} def2 - Second definition\r\n * @returns {boolean} - Whether the definitions are similar\r\n */\nfunction areSimilarDefinitions(def1, def2) {\n  // Simple implementation: check if definitions share significant words\n  const words1 = def1.toLowerCase().split(/\\W+/).filter(w => w.length > 3);\n  const words2 = def2.toLowerCase().split(/\\W+/).filter(w => w.length > 3);\n\n  // Count shared significant words\n  const sharedWords = words1.filter(w => words2.includes(w));\n\n  // If more than 30% of words are shared, consider them similar\n  return sharedWords.length > 0 && sharedWords.length / Math.min(words1.length, words2.length) > 0.3;\n}\n\n/**\r\n * Shuffles an array using the Fisher-Yates algorithm\r\n * @param {Array} array - The array to shuffle\r\n * @returns {Array} - The shuffled array\r\n */\nfunction shuffleArray(array) {\n  const result = [...array];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}","map":{"version":3,"names":["wordDatabase","recentlyUsedWords","Set","MAX_RECENT_WORDS","selectWordsForGame","difficulty","count","availableWords","filter","word","filteredWords","has","id","length","additionalWords","remainingNeeded","recentlyUsedArray","Array","from","map","find","prioritizedRecent","slice","shuffledWords","shuffleArray","selectedWords","forEach","add","size","oldestWord","values","next","value","delete","error","console","Error","getWordById","wordId","w","getWordsByDifficulty","words","getWordsByCategory","category","categories","includes","getDistractorsForWord","relatedDistractors","relatedWords","some","cat","relatedWord","meanings","meaning","isDifferentMeaning","every","m","areSimilarDefinitions","definition","push","forWordTypes","partOfSpeech","source","fallbackDistractors","allDistractors","filteredDistractors","distractor","type","prioritizedDistractors","d","shuffledDistractors","selectedDistractors","def1","def2","words1","toLowerCase","split","words2","sharedWords","Math","min","array","result","i","j","floor","random"],"sources":["C:/Users/abhay/Downloads/WordsEmptyMeaning/src/services/wordService.js"],"sourcesContent":["import { wordDatabase } from '../data/wordDatabase';\r\n\r\n// Keep track of recently used words to prevent repetition\r\nconst recentlyUsedWords = new Set();\r\nconst MAX_RECENT_WORDS = 50; // Maximum number of words to track\r\n\r\n/**\r\n * Selects words for a game based on difficulty and count\r\n * @param {string} difficulty - The difficulty level ('easy', 'medium', 'hard')\r\n * @param {number} count - The number of words to select\r\n * @returns {Promise<Array>} - A promise that resolves to an array of selected words\r\n */\r\nexport const selectWordsForGame = async (difficulty, count) => {\r\n  try {\r\n    // Get words of the requested difficulty\r\n    let availableWords = wordDatabase.filter(word => word.difficulty === difficulty);\r\n    \r\n    // Filter out recently used words to prevent repetition\r\n    let filteredWords = availableWords.filter(word => !recentlyUsedWords.has(word.id));\r\n    \r\n    // If not enough words after filtering, expand to adjacent difficulties\r\n    if (filteredWords.length < count) {\r\n      let additionalWords = [];\r\n      \r\n      if (difficulty === 'easy') {\r\n        additionalWords = wordDatabase.filter(word =>\r\n          word.difficulty === 'medium' && !recentlyUsedWords.has(word.id)\r\n        );\r\n      } else if (difficulty === 'hard') {\r\n        additionalWords = wordDatabase.filter(word =>\r\n          word.difficulty === 'medium' && !recentlyUsedWords.has(word.id)\r\n        );\r\n      } else {\r\n        additionalWords = [\r\n          ...wordDatabase.filter(word =>\r\n            word.difficulty === 'easy' && !recentlyUsedWords.has(word.id)\r\n          ),\r\n          ...wordDatabase.filter(word =>\r\n            word.difficulty === 'hard' && !recentlyUsedWords.has(word.id)\r\n          )\r\n        ];\r\n      }\r\n      \r\n      filteredWords = [...filteredWords, ...additionalWords];\r\n    }\r\n    \r\n    // If still not enough words, include some recently used words as a last resort\r\n    if (filteredWords.length < count) {\r\n      const remainingNeeded = count - filteredWords.length;\r\n      const recentlyUsedArray = Array.from(recentlyUsedWords)\r\n        .map(id => wordDatabase.find(word => word.id === id))\r\n        .filter(word => word); // Filter out any undefined values\r\n      \r\n      // Prioritize words of the requested difficulty\r\n      const prioritizedRecent = [\r\n        ...recentlyUsedArray.filter(word => word.difficulty === difficulty),\r\n        ...recentlyUsedArray.filter(word => word.difficulty !== difficulty)\r\n      ];\r\n      \r\n      filteredWords = [...filteredWords, ...prioritizedRecent.slice(0, remainingNeeded)];\r\n    }\r\n    \r\n    // Shuffle and select required number of words\r\n    const shuffledWords = shuffleArray(filteredWords);\r\n    const selectedWords = shuffledWords.slice(0, count);\r\n    \r\n    // Add selected words to recently used set\r\n    selectedWords.forEach(word => {\r\n      recentlyUsedWords.add(word.id);\r\n      \r\n      // If the set gets too large, remove the oldest entries\r\n      if (recentlyUsedWords.size > MAX_RECENT_WORDS) {\r\n        const oldestWord = recentlyUsedWords.values().next().value;\r\n        recentlyUsedWords.delete(oldestWord);\r\n      }\r\n    });\r\n    \r\n    return selectedWords;\r\n  } catch (error) {\r\n    console.error('Error selecting words:', error);\r\n    throw new Error('Failed to select words for the game');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets a word by its ID\r\n * @param {string} wordId - The ID of the word to retrieve\r\n * @returns {Promise<Object>} - A promise that resolves to the word object\r\n */\r\nexport const getWordById = async (wordId) => {\r\n  try {\r\n    const word = wordDatabase.find(w => w.id === wordId);\r\n    \r\n    if (!word) {\r\n      throw new Error(`Word with ID ${wordId} not found`);\r\n    }\r\n    \r\n    return word;\r\n  } catch (error) {\r\n    console.error('Error getting word:', error);\r\n    throw new Error('Failed to get word');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets words by difficulty level\r\n * @param {string} difficulty - The difficulty level ('easy', 'medium', 'hard')\r\n * @returns {Promise<Array>} - A promise that resolves to an array of words\r\n */\r\nexport const getWordsByDifficulty = async (difficulty) => {\r\n  try {\r\n    const words = wordDatabase.filter(word => word.difficulty === difficulty);\r\n    return words;\r\n  } catch (error) {\r\n    console.error('Error getting words by difficulty:', error);\r\n    throw new Error('Failed to get words by difficulty');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets words by category\r\n * @param {string} category - The category to filter by\r\n * @returns {Promise<Array>} - A promise that resolves to an array of words\r\n */\r\nexport const getWordsByCategory = async (category) => {\r\n  try {\r\n    const words = wordDatabase.filter(word => word.categories.includes(category));\r\n    return words;\r\n  } catch (error) {\r\n    console.error('Error getting words by category:', error);\r\n    throw new Error('Failed to get words by category');\r\n  }\r\n};\r\n\r\n/**\r\n * Gets distractors for a word\r\n * @param {Object} word - The word to get distractors for\r\n * @param {number} count - The number of distractors to get\r\n * @returns {Promise<Array>} - A promise that resolves to an array of distractors\r\n */\r\nexport const getDistractorsForWord = async (word, count) => {\r\n  try {\r\n    // Enhanced distractor generation\r\n    // First, try to find semantically related but incorrect definitions from other words\r\n    const relatedDistractors = [];\r\n    \r\n    // Look for words in the same categories but with different meanings\r\n    const relatedWords = wordDatabase.filter(w =>\r\n      w.id !== word.id && // Not the same word\r\n      w.categories.some(cat => word.categories.includes(cat)) // Has at least one matching category\r\n    );\r\n    \r\n    // Extract meanings from related words\r\n    if (relatedWords.length > 0) {\r\n      relatedWords.forEach(relatedWord => {\r\n        relatedWord.meanings.forEach(meaning => {\r\n          // Check if this meaning is sufficiently different from our word's meanings\r\n          const isDifferentMeaning = word.meanings.every(m =>\r\n            !areSimilarDefinitions(m.definition, meaning.definition)\r\n          );\r\n          \r\n          if (isDifferentMeaning) {\r\n            relatedDistractors.push({\r\n              id: `distractor_${relatedWord.id}_${meaning.id}`,\r\n              definition: meaning.definition,\r\n              forWordTypes: [meaning.partOfSpeech],\r\n              difficulty: word.difficulty,\r\n              source: 'related_word'\r\n            });\r\n          }\r\n        });\r\n      });\r\n    }\r\n    \r\n    // Fallback distractors if we don't have enough related ones\r\n    const fallbackDistractors = [\r\n      {\r\n        id: 'distractor_001',\r\n        definition: 'To prepare food by heating it in an oven',\r\n        forWordTypes: ['noun', 'verb'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_002',\r\n        definition: 'A small, round fruit with red or green skin',\r\n        forWordTypes: ['noun'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_003',\r\n        definition: 'A device used for measuring time',\r\n        forWordTypes: ['noun'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_004',\r\n        definition: 'A large, four-legged animal with a trunk',\r\n        forWordTypes: ['noun'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_005',\r\n        definition: 'To move quickly on foot',\r\n        forWordTypes: ['verb'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_006',\r\n        definition: 'A small, flying insect that produces honey',\r\n        forWordTypes: ['noun'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_007',\r\n        definition: 'A tall plant with a hard trunk and branches',\r\n        forWordTypes: ['noun'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      },\r\n      {\r\n        id: 'distractor_008',\r\n        definition: 'To speak in a loud voice',\r\n        forWordTypes: ['verb'],\r\n        difficulty: word.difficulty,\r\n        source: 'fallback'\r\n      }\r\n    ];\r\n    \r\n    // Combine related and fallback distractors\r\n    const allDistractors = [...relatedDistractors, ...fallbackDistractors];\r\n    \r\n    // Filter distractors that are appropriate for this word's type\r\n    const filteredDistractors = allDistractors.filter(distractor =>\r\n      distractor.forWordTypes.some(type => word.categories.includes(type))\r\n    );\r\n    \r\n    // Prioritize related distractors over fallback ones\r\n    const prioritizedDistractors = [\r\n      ...filteredDistractors.filter(d => d.source === 'related_word'),\r\n      ...filteredDistractors.filter(d => d.source === 'fallback')\r\n    ];\r\n    \r\n    // Shuffle and select required number of distractors\r\n    const shuffledDistractors = shuffleArray(prioritizedDistractors);\r\n    const selectedDistractors = shuffledDistractors.slice(0, count);\r\n    \r\n    return selectedDistractors;\r\n  } catch (error) {\r\n    console.error('Error getting distractors:', error);\r\n    throw new Error('Failed to get distractors for word');\r\n  }\r\n};\r\n\r\n/**\r\n * Checks if two definitions are similar\r\n * @param {string} def1 - First definition\r\n * @param {string} def2 - Second definition\r\n * @returns {boolean} - Whether the definitions are similar\r\n */\r\nfunction areSimilarDefinitions(def1, def2) {\r\n  // Simple implementation: check if definitions share significant words\r\n  const words1 = def1.toLowerCase().split(/\\W+/).filter(w => w.length > 3);\r\n  const words2 = def2.toLowerCase().split(/\\W+/).filter(w => w.length > 3);\r\n  \r\n  // Count shared significant words\r\n  const sharedWords = words1.filter(w => words2.includes(w));\r\n  \r\n  // If more than 30% of words are shared, consider them similar\r\n  return sharedWords.length > 0 &&\r\n         (sharedWords.length / Math.min(words1.length, words2.length)) > 0.3;\r\n}\r\n\r\n/**\r\n * Shuffles an array using the Fisher-Yates algorithm\r\n * @param {Array} array - The array to shuffle\r\n * @returns {Array} - The shuffled array\r\n */\r\nfunction shuffleArray(array) {\r\n  const result = [...array];\r\n  \r\n  for (let i = result.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [result[i], result[j]] = [result[j], result[i]];\r\n  }\r\n  \r\n  return result;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}